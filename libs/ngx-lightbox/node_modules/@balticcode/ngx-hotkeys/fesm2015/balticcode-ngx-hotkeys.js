import { InjectionToken, Inject, Injectable, Directive, ElementRef, Input, Component, NgModule } from '@angular/core';
import { Subject } from 'rxjs';
import 'mousetrap';
import { share } from 'rxjs/internal/operators';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const HotkeyOptions = new InjectionToken('HotkeyOptions');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
/** @type {?} */
const _defaultOptions = {
    disableCheatSheet: false,
    cheatSheetTitle: 'Keyboard Shortcuts:',
    cheatSheetHotkey: '?',
    cheatSheetHotkeyDescription: 'Show / hide this help menu',
    cheatSheetCloseEsc: false,
    cheatSheetCloseEscDescription: 'Hide this help menu'
};
class NgxHotkeysService {
    /**
     * @param {?} _options
     */
    constructor(_options) {
        this._options = _options;
        this._registeredHotkeys = new Set();
        this._pausedHotkeys = new Set();
        this._cheatSheetToggled = new Subject();
        this._preventIn = ['INPUT', 'SELECT', 'TEXTAREA'];
        this._serviceOptions = Object.assign(_defaultOptions, this._options);
        Mousetrap.prototype.stopCallback = (event, element, combo, callback) => {
            // if the element has the class "mousetrap" then no need to stop
            if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
                return false;
            }
            return (element.contentEditable && element.contentEditable === 'true');
        };
        this._mousetrapInstance = new (/** @type {?} */ (Mousetrap))();
        if (!this._serviceOptions.disableCheatSheet) {
            this.register({
                combo: this._serviceOptions.cheatSheetHotkey,
                handler: function (event) {
                    this._cheatSheetToggled.next();
                }.bind(this),
                description: this._serviceOptions.cheatSheetHotkeyDescription
            });
        }
        if (this._serviceOptions.cheatSheetCloseEsc) {
            this.register({
                combo: 'esc',
                handler: function (event) {
                    this._cheatSheetToggled.next(false);
                }.bind(this),
                allowIn: ['HOTKEYS-CHEATSHEET'],
                description: this._serviceOptions.cheatSheetCloseEscDescription
            });
        }
    }
    /**
     * Returns the registered hotkeys as array.
     * @return {?} all registered hotkeys
     */
    get hotkeys() {
        return Array.from(this._registeredHotkeys);
    }
    /**
     * Returns an Observable stream indicating the cheatsheets visibility was toggled.
     * @return {?} stream indicating the cheatsheets visibility was toggled
     */
    get cheatSheetToggled() {
        return this._cheatSheetToggled.asObservable().pipe(share());
    }
    /**
     * @return {?}
     */
    get options() {
        return this._serviceOptions;
    }
    /**
     * Registers a new hotkey/new hotkeys with it's/their handler(s).
     * @param {?} hotkey hotkeys to listen for
     * @param {?=} unpausing flag indicating if the hotkeys should be unpaused
     * @return {?}
     */
    register(hotkey, unpausing = false) {
        /** @type {?} */
        let hotkeys = [].concat(hotkey);
        if (unpausing) {
            hotkeys = Array.from(this._pausedHotkeys);
        }
        hotkeys.forEach(h => {
            if (unpausing) {
                this._pausedHotkeys.delete(h);
            }
            this._registeredHotkeys.add(h);
            this.bindToMoustrap(h);
        });
    }
    /**
     * Removes a/the registered hotkey(s).
     * @param {?} hotkey hotkey filter
     * @param {?=} pausing flag indicating if the hotkeys should be paused
     * @return {?}
     */
    unregister(hotkey, pausing = false) {
        /** @type {?} */
        const hotkeys = [].concat(hotkey);
        hotkeys.forEach(h => {
            this._registeredHotkeys.delete(h);
            if (pausing) {
                this._pausedHotkeys.add(h);
            }
            this._mousetrapInstance.unbind(h.combo, h.specificEvent);
        });
    }
    /**
     * Returns all hotkeys matching the passed combo(s).
     * @param {?=} combo combo to match against
     * @return {?} all matched hotkeys
     */
    get(combo) {
        return this.hotkeys.filter(h => h.combo === combo);
    }
    /**
     * Stops listening for the specified hotkeys.
     * @param {?=} hotkey hotkey filter
     * @return {?}
     */
    pause(hotkey) {
        if (!hotkey) {
            return this.pause(this.hotkeys);
        }
        /** @type {?} */
        const hotkeys = [].concat(hotkey);
        this.unregister(hotkeys, true);
    }
    /**
     * Resumes listening for the specified hotkeys.
     * @param {?=} hotkey hotkey filter
     * @return {?}
     */
    unpause(hotkey) {
        if (!hotkey) {
            return this.unpause(this.hotkeys);
        }
        /** @type {?} */
        const hotkeys = [].concat(hotkey);
        this.register(hotkeys, true);
    }
    /**
     * Resets all hotkeys.
     * @return {?}
     */
    reset() {
        this._mousetrapInstance.reset();
        this._registeredHotkeys.clear();
        this._pausedHotkeys.clear();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.reset();
    }
    /**
     * @param {?} hotkey
     * @return {?}
     */
    bindToMoustrap(hotkey) {
        this._mousetrapInstance.bind(hotkey.combo, (event, combo) => {
            /** @type {?} */
            let shouldExecute = true;
            // if the callback is executed directly `hotkey.get('w').callback()`
            // there will be no event, so just execute the callback.
            if (event) {
                /** @type {?} */
                const target = /** @type {?} */ ((event.target || event.srcElement));
                /** @type {?} */
                const nodeName = target.nodeName.toUpperCase();
                // check if the input has a mousetrap class, and skip checking preventIn if so
                if ((' ' + target.className + ' ').indexOf(' mousetrap ') > -1) {
                    shouldExecute = true;
                }
                else if (this._preventIn.indexOf(nodeName) > -1 && hotkey.allowIn.map(allow => allow.toUpperCase()).indexOf(nodeName) === -1) {
                    // don't execute callback if the event was fired from inside an element listed in preventIn but not in allowIn
                    shouldExecute = false;
                }
            }
            if (shouldExecute) {
                return hotkey.handler.apply(this, [event, combo]);
            }
        }, hotkey.specificEvent);
    }
}
NgxHotkeysService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NgxHotkeysService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [HotkeyOptions,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NgxHotkeysDirective {
    /**
     * @param {?} _hotkeysService
     * @param {?} _elementRef
     */
    constructor(_hotkeysService, _elementRef) {
        this._hotkeysService = _hotkeysService;
        this._elementRef = _elementRef;
        this._hotkeysList = [];
        this._oldHotkeys = [];
        this._mousetrapInstance = new Mousetrap(this._elementRef.nativeElement); // Bind hotkeys to the current element (and any children)
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        for (const hotkey of this.hotkeys) {
            /** @type {?} */
            const combo = Object.keys(hotkey)[0];
            /** @type {?} */
            const hotkeyObj = {
                combo: combo,
                handler: hotkey[combo]
            };
            /** @type {?} */
            const filtered = this._hotkeysService.get(combo);
            /** @type {?} */
            const oldHotkey = !!filtered && !!filtered.length ? filtered[0] : null;
            if (oldHotkey !== null) { // We let the user overwrite callbacks temporarily if you specify it in HTML
                // We let the user overwrite callbacks temporarily if you specify it in HTML
                this._oldHotkeys.push(oldHotkey);
                this._hotkeysService.unregister(oldHotkey);
            }
            this._hotkeysList.push(hotkeyObj);
            this._mousetrapInstance.bind(hotkeyObj.combo, hotkeyObj.handler);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        for (const hotkey of this._hotkeysList) {
            this._mousetrapInstance.unbind(hotkey.combo);
        }
        this._hotkeysService.register(this._oldHotkeys);
    }
}
NgxHotkeysDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngxHotkeys]',
                providers: [NgxHotkeysService]
            },] }
];
/** @nocollapse */
NgxHotkeysDirective.ctorParameters = () => [
    { type: NgxHotkeysService },
    { type: ElementRef }
];
NgxHotkeysDirective.propDecorators = {
    hotkeys: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NgxCheatsheetComponent {
    /**
     * @param {?} hotkeysService
     */
    constructor(hotkeysService) {
        this.hotkeysService = hotkeysService;
        this.helpVisible = false;
        this._map = {
            command: '\u2318',
            // ⌘
            shift: '\u21E7',
            // ⇧
            left: '\u2190',
            // ←
            right: '\u2192',
            // →
            up: '\u2191',
            // ↑
            down: '\u2193',
            // ↓
            'return': '\u23CE',
            // ⏎
            backspace: '\u232B' // ⌫
        };
        this.title = this.hotkeysService.options.cheatSheetTitle;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._subscription = this.hotkeysService.cheatSheetToggled
            .subscribe((isOpen) => {
            if (isOpen !== false) {
                this.hotkeys = this.hotkeysService.hotkeys
                    .filter(hotkey => hotkey.description);
            }
            if (isOpen === false) {
                this.helpVisible = false;
            }
            else {
                this.toggleCheatSheet();
            }
        });
    }
    /**
     * @param {?} hotkey
     * @return {?}
     */
    formatHotkey(hotkey) {
        if (!hotkey.format) {
            /** @type {?} */
            const combo = Array.isArray(hotkey.combo) ? hotkey.combo[0] : hotkey.combo;
            /** @type {?} */
            const sequence = combo.split(/[\s]/);
            for (let i = 0; i < sequence.length; i++) {
                sequence[i] = this.symbolize(sequence[i]);
            }
            hotkey.format = sequence;
        }
        return hotkey.format;
    }
    /**
     * @param {?} combo
     * @return {?}
     */
    symbolize(combo) {
        /** @type {?} */
        const comboSplit = combo.split('+');
        for (let i = 0; i < comboSplit.length; i++) {
            // try to resolve command / ctrl based on OS:
            if (comboSplit[i] === 'mod') {
                if (window.navigator && window.navigator.platform.indexOf('Mac') >= 0) {
                    comboSplit[i] = 'command';
                }
                else {
                    comboSplit[i] = 'ctrl';
                }
            }
            comboSplit[i] = this._map[comboSplit[i]] || comboSplit[i];
        }
        return comboSplit.join(' + ');
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this._subscription) {
            this._subscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    toggleCheatSheet() {
        this.helpVisible = !this.helpVisible;
    }
}
NgxCheatsheetComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-cheatsheet',
                template: "<div class=\"ngx-cheatsheet fade\" [ngClass]=\"{'in': helpVisible}\" style=\"display:none\">\n  <div class=\"ngx-cheatsheet__hotkeys\">\n    <h4 class=\"ngx-cheatsheet__hotkeys__title\">{{ title }}</h4>\n    <table>\n      <tbody>\n      <tr *ngFor=\"let hotkey of hotkeys\">\n        <td class=\"ngx-cheatsheet__hotkeys__keys\">\n          <span class=\"ngx-cheatsheet__hotkeys__keys__key\">{{ formatHotkey(hotkey) }}</span>\n        </td>\n        <td class=\"ngx-cheatsheet__hotkeys__keys__text\">{{ hotkey.description }}</td>\n      </tr>\n      </tbody>\n    </table>\n    <div class=\"ngx-cheatsheet__hotkeys__close\" (click)=\"toggleCheatSheet()\">&#215;</div>\n  </div>\n</div>\n",
                styles: [".ngx-cheatsheet{display:table!important;position:fixed;width:100%;height:100%;top:0;left:0;color:#333;font-size:1em;background-color:rgba(255,255,255,.9)}.ngx-cheatsheet.fade{z-index:-1024;visibility:hidden;opacity:0;transition:opacity .15s linear}.ngx-cheatsheet.fade.in{z-index:10002;visibility:visible;opacity:1}.ngx-cheatsheet__hotkeys{width:100%;height:100%;display:table-cell;vertical-align:middle}.ngx-cheatsheet__hotkeys__title{font-weight:700;text-align:center;font-size:1.2em}.ngx-cheatsheet__hotkeys table{margin:auto;color:#333}.ngx-cheatsheet__hotkeys__keys{padding:5px;text-align:right}.ngx-cheatsheet__hotkeys__keys__key{display:inline-block;color:#fff;background-color:#333;border:1px solid #333;border-radius:5px;text-align:center;margin-right:5px;box-shadow:inset 0 1px 0 #666,0 1px 0 #bbb;padding:5px 9px;font-size:1em}.ngx-cheatsheet__hotkeys__keys__text{padding-left:10px;font-size:1em}.ngx-cheatsheet__hotkeys__close{position:fixed;top:20px;right:20px;font-size:2em;font-weight:700;padding:5px 10px;border:1px solid #ddd;border-radius:5px;min-height:45px;min-width:45px;text-align:center}@media all and (max-width:500px){.ngx-cheatsheet__hotkeys{font-size:.8em}}@media all and (min-width:750px){.ngx-cheatsheet__hotkeys{font-size:1.2em}}"]
            }] }
];
/** @nocollapse */
NgxCheatsheetComponent.ctorParameters = () => [
    { type: NgxHotkeysService }
];
NgxCheatsheetComponent.propDecorators = {
    title: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
class NgxHotkeysModule {
    /**
     * @param {?=} options
     * @return {?}
     */
    static forRoot(options) {
        return {
            ngModule: NgxHotkeysModule,
            providers: [
                NgxHotkeysService,
                { provide: HotkeyOptions, useValue: options }
            ]
        };
    }
}
NgxHotkeysModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [NgxCheatsheetComponent, NgxHotkeysDirective],
                exports: [NgxHotkeysDirective, NgxCheatsheetComponent],
                providers: [NgxHotkeysService]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */

export { NgxHotkeysService, NgxHotkeysDirective, NgxCheatsheetComponent, NgxHotkeysModule, HotkeyOptions as ɵa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFsdGljY29kZS1uZ3gtaG90a2V5cy5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQGJhbHRpY2NvZGUvbmd4LWhvdGtleXMvbGliL3Rva2VuLnRzIiwibmc6Ly9AYmFsdGljY29kZS9uZ3gtaG90a2V5cy9saWIvbmd4LWhvdGtleXMuc2VydmljZS50cyIsIm5nOi8vQGJhbHRpY2NvZGUvbmd4LWhvdGtleXMvbGliL25neC1ob3RrZXlzLmRpcmVjdGl2ZS50cyIsIm5nOi8vQGJhbHRpY2NvZGUvbmd4LWhvdGtleXMvbGliL25neC1jaGVhdHNoZWV0L25neC1jaGVhdHNoZWV0LmNvbXBvbmVudC50cyIsIm5nOi8vQGJhbHRpY2NvZGUvbmd4LWhvdGtleXMvbGliL25neC1ob3RrZXlzLm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0luamVjdGlvblRva2VufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCB7SUhvdGtleU9wdGlvbnN9IGZyb20gJy4vaW50ZXJmYWNlcyc7XHJcblxyXG5leHBvcnQgY29uc3QgSG90a2V5T3B0aW9ucyA9IG5ldyBJbmplY3Rpb25Ub2tlbjxJSG90a2V5T3B0aW9ucz4oJ0hvdGtleU9wdGlvbnMnKTtcclxuIiwiaW1wb3J0IHtJbmplY3QsIEluamVjdGFibGUsIE9uRGVzdHJveX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge09ic2VydmFibGUsIFN1YmplY3R9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgJ21vdXNldHJhcCc7XG5cbmltcG9ydCB7SUhvdGtleSwgSUhvdGtleU9wdGlvbnN9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQge0hvdGtleU9wdGlvbnN9IGZyb20gJy4vdG9rZW4nO1xuaW1wb3J0IHtzaGFyZX0gZnJvbSAncnhqcy9pbnRlcm5hbC9vcGVyYXRvcnMnO1xuXG5jb25zdCBfZGVmYXVsdE9wdGlvbnM6IElIb3RrZXlPcHRpb25zID0ge1xuICBkaXNhYmxlQ2hlYXRTaGVldDogZmFsc2UsXG4gIGNoZWF0U2hlZXRUaXRsZTogJ0tleWJvYXJkIFNob3J0Y3V0czonLFxuICBjaGVhdFNoZWV0SG90a2V5OiAnPycsXG4gIGNoZWF0U2hlZXRIb3RrZXlEZXNjcmlwdGlvbjogJ1Nob3cgLyBoaWRlIHRoaXMgaGVscCBtZW51JyxcbiAgY2hlYXRTaGVldENsb3NlRXNjOiBmYWxzZSxcbiAgY2hlYXRTaGVldENsb3NlRXNjRGVzY3JpcHRpb246ICdIaWRlIHRoaXMgaGVscCBtZW51J1xufTtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5neEhvdGtleXNTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICBwcml2YXRlIF9zZXJ2aWNlT3B0aW9uczogSUhvdGtleU9wdGlvbnM7XG4gIHByaXZhdGUgX3JlZ2lzdGVyZWRIb3RrZXlzOiBTZXQ8SUhvdGtleT4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgX3BhdXNlZEhvdGtleXM6IFNldDxJSG90a2V5PiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBfbW91c2V0cmFwSW5zdGFuY2U6IE1vdXNldHJhcEluc3RhbmNlO1xuICBwcml2YXRlIF9jaGVhdFNoZWV0VG9nZ2xlZDogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3QoKTtcbiAgcHJpdmF0ZSBfcHJldmVudEluID0gWydJTlBVVCcsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXTtcblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KEhvdGtleU9wdGlvbnMpIHByaXZhdGUgX29wdGlvbnM6IElIb3RrZXlPcHRpb25zKSB7XG4gICAgdGhpcy5fc2VydmljZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKF9kZWZhdWx0T3B0aW9ucywgdGhpcy5fb3B0aW9ucyk7XG4gICAgTW91c2V0cmFwLnByb3RvdHlwZS5zdG9wQ2FsbGJhY2sgPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBjb21ibzogc3RyaW5nLCBjYWxsYmFjazogRnVuY3Rpb24pID0+IHtcbiAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3MgXCJtb3VzZXRyYXBcIiB0aGVuIG5vIG5lZWQgdG8gc3RvcFxuICAgICAgaWYgKCgnICcgKyBlbGVtZW50LmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignIG1vdXNldHJhcCAnKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoZWxlbWVudC5jb250ZW50RWRpdGFibGUgJiYgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG4gICAgfTtcbiAgICB0aGlzLl9tb3VzZXRyYXBJbnN0YW5jZSA9IG5ldyAoPGFueT5Nb3VzZXRyYXApKCk7XG4gICAgaWYgKCF0aGlzLl9zZXJ2aWNlT3B0aW9ucy5kaXNhYmxlQ2hlYXRTaGVldCkge1xuICAgICAgdGhpcy5yZWdpc3Rlcih7XG4gICAgICAgIGNvbWJvOiB0aGlzLl9zZXJ2aWNlT3B0aW9ucy5jaGVhdFNoZWV0SG90a2V5LFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICB0aGlzLl9jaGVhdFNoZWV0VG9nZ2xlZC5uZXh0KCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuX3NlcnZpY2VPcHRpb25zLmNoZWF0U2hlZXRIb3RrZXlEZXNjcmlwdGlvblxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlcnZpY2VPcHRpb25zLmNoZWF0U2hlZXRDbG9zZUVzYykge1xuICAgICAgdGhpcy5yZWdpc3Rlcih7XG4gICAgICAgIGNvbWJvOiAnZXNjJyxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgICAgdGhpcy5fY2hlYXRTaGVldFRvZ2dsZWQubmV4dChmYWxzZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgYWxsb3dJbjogWydIT1RLRVlTLUNIRUFUU0hFRVQnXSxcbiAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuX3NlcnZpY2VPcHRpb25zLmNoZWF0U2hlZXRDbG9zZUVzY0Rlc2NyaXB0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVnaXN0ZXJlZCBob3RrZXlzIGFzIGFycmF5LlxuICAgKiBAcmV0dXJucyBhbGwgcmVnaXN0ZXJlZCBob3RrZXlzXG4gICAqL1xuICBwdWJsaWMgZ2V0IGhvdGtleXMoKTogSUhvdGtleVtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9yZWdpc3RlcmVkSG90a2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHN0cmVhbSBpbmRpY2F0aW5nIHRoZSBjaGVhdHNoZWV0cyB2aXNpYmlsaXR5IHdhcyB0b2dnbGVkLlxuICAgKiBAcmV0dXJucyBzdHJlYW0gaW5kaWNhdGluZyB0aGUgY2hlYXRzaGVldHMgdmlzaWJpbGl0eSB3YXMgdG9nZ2xlZFxuICAgKi9cbiAgcHVibGljIGdldCBjaGVhdFNoZWV0VG9nZ2xlZCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fY2hlYXRTaGVldFRvZ2dsZWQuYXNPYnNlcnZhYmxlKCkucGlwZShcbiAgICAgIHNoYXJlKClcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGdldCBvcHRpb25zKCk6IElIb3RrZXlPcHRpb25zIHtcbiAgICByZXR1cm4gdGhpcy5fc2VydmljZU9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbmV3IGhvdGtleS9uZXcgaG90a2V5cyB3aXRoIGl0J3MvdGhlaXIgaGFuZGxlcihzKS5cbiAgICogQHBhcmFtIGhvdGtleSBob3RrZXlzIHRvIGxpc3RlbiBmb3JcbiAgICogQHBhcmFtIHVucGF1c2luZyBmbGFnIGluZGljYXRpbmcgaWYgdGhlIGhvdGtleXMgc2hvdWxkIGJlIHVucGF1c2VkXG4gICAqL1xuICBwdWJsaWMgcmVnaXN0ZXIoaG90a2V5OiBJSG90a2V5IHwgSUhvdGtleVtdLCB1bnBhdXNpbmcgPSBmYWxzZSk6IHZvaWQge1xuICAgIGxldCBob3RrZXlzOiBJSG90a2V5W10gPSBbXS5jb25jYXQoaG90a2V5KTtcbiAgICBpZiAodW5wYXVzaW5nKSB7XG4gICAgICBob3RrZXlzID0gQXJyYXkuZnJvbSh0aGlzLl9wYXVzZWRIb3RrZXlzKTtcbiAgICB9XG4gICAgaG90a2V5cy5mb3JFYWNoKGggPT4ge1xuICAgICAgaWYgKHVucGF1c2luZykge1xuICAgICAgICB0aGlzLl9wYXVzZWRIb3RrZXlzLmRlbGV0ZShoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlZ2lzdGVyZWRIb3RrZXlzLmFkZChoKTtcbiAgICAgIHRoaXMuYmluZFRvTW91c3RyYXAoaCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhL3RoZSByZWdpc3RlcmVkIGhvdGtleShzKS5cbiAgICogQHBhcmFtIGhvdGtleSBob3RrZXkgZmlsdGVyXG4gICAqIEBwYXJhbSBwYXVzaW5nIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgaG90a2V5cyBzaG91bGQgYmUgcGF1c2VkXG4gICAqL1xuICBwdWJsaWMgdW5yZWdpc3Rlcihob3RrZXk6IElIb3RrZXkgfCBJSG90a2V5W10sIHBhdXNpbmcgPSBmYWxzZSk6IHZvaWQge1xuICAgIGNvbnN0IGhvdGtleXM6IElIb3RrZXlbXSA9IFtdLmNvbmNhdChob3RrZXkpO1xuXG4gICAgaG90a2V5cy5mb3JFYWNoKGggPT4ge1xuICAgICAgdGhpcy5fcmVnaXN0ZXJlZEhvdGtleXMuZGVsZXRlKGgpO1xuICAgICAgaWYgKHBhdXNpbmcpIHtcbiAgICAgICAgdGhpcy5fcGF1c2VkSG90a2V5cy5hZGQoaCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tb3VzZXRyYXBJbnN0YW5jZS51bmJpbmQoaC5jb21ibywgaC5zcGVjaWZpY0V2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBob3RrZXlzIG1hdGNoaW5nIHRoZSBwYXNzZWQgY29tYm8ocykuXG4gICAqIEBwYXJhbSBjb21ibyBjb21ibyB0byBtYXRjaCBhZ2FpbnN0XG4gICAqIEByZXR1cm5zIGFsbCBtYXRjaGVkIGhvdGtleXNcbiAgICovXG4gIHB1YmxpYyBnZXQoY29tYm8/OiBzdHJpbmcgfCBzdHJpbmdbXSk6IElIb3RrZXlbXSB7XG4gICAgcmV0dXJuIHRoaXMuaG90a2V5cy5maWx0ZXIoaCA9PiBoLmNvbWJvID09PSBjb21ibyk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgbGlzdGVuaW5nIGZvciB0aGUgc3BlY2lmaWVkIGhvdGtleXMuXG4gICAqIEBwYXJhbSBob3RrZXkgaG90a2V5IGZpbHRlclxuICAgKi9cbiAgcHVibGljIHBhdXNlKGhvdGtleT86IElIb3RrZXkgfCBJSG90a2V5W10pOiB2b2lkIHtcbiAgICBpZiAoIWhvdGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMucGF1c2UodGhpcy5ob3RrZXlzKTtcbiAgICB9XG4gICAgY29uc3QgaG90a2V5czogSUhvdGtleVtdID0gW10uY29uY2F0KGhvdGtleSk7XG4gICAgdGhpcy51bnJlZ2lzdGVyKGhvdGtleXMsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZXMgbGlzdGVuaW5nIGZvciB0aGUgc3BlY2lmaWVkIGhvdGtleXMuXG4gICAqIEBwYXJhbSBob3RrZXkgaG90a2V5IGZpbHRlclxuICAgKi9cbiAgcHVibGljIHVucGF1c2UoaG90a2V5PzogSUhvdGtleSB8IElIb3RrZXlbXSk6IHZvaWQge1xuICAgIGlmICghaG90a2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy51bnBhdXNlKHRoaXMuaG90a2V5cyk7XG4gICAgfVxuICAgIGNvbnN0IGhvdGtleXM6IElIb3RrZXlbXSA9IFtdLmNvbmNhdChob3RrZXkpO1xuICAgIHRoaXMucmVnaXN0ZXIoaG90a2V5cywgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIGFsbCBob3RrZXlzLlxuICAgKi9cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuX21vdXNldHJhcEluc3RhbmNlLnJlc2V0KCk7XG4gICAgdGhpcy5fcmVnaXN0ZXJlZEhvdGtleXMuY2xlYXIoKTtcbiAgICB0aGlzLl9wYXVzZWRIb3RrZXlzLmNsZWFyKCk7XG4gIH1cblxuICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBiaW5kVG9Nb3VzdHJhcChob3RrZXk6IElIb3RrZXkpOiB2b2lkIHtcblxuICAgIHRoaXMuX21vdXNldHJhcEluc3RhbmNlLmJpbmQoaG90a2V5LmNvbWJvLFxuICAgICAgKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBjb21ibzogc3RyaW5nKSA9PiB7XG4gICAgICAgIGxldCBzaG91bGRFeGVjdXRlID0gdHJ1ZTtcblxuICAgICAgICAvLyBpZiB0aGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgZGlyZWN0bHkgYGhvdGtleS5nZXQoJ3cnKS5jYWxsYmFjaygpYFxuICAgICAgICAvLyB0aGVyZSB3aWxsIGJlIG5vIGV2ZW50LCBzbyBqdXN0IGV4ZWN1dGUgdGhlIGNhbGxiYWNrLlxuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXQ6IEhUTUxFbGVtZW50ID0gPEhUTUxFbGVtZW50PihldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudCk7IC8vIHNyY0VsZW1lbnQgaXMgSUUgb25seVxuICAgICAgICAgIGNvbnN0IG5vZGVOYW1lOiBzdHJpbmcgPSB0YXJnZXQubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBpbnB1dCBoYXMgYSBtb3VzZXRyYXAgY2xhc3MsIGFuZCBza2lwIGNoZWNraW5nIHByZXZlbnRJbiBpZiBzb1xuICAgICAgICAgIGlmICgoJyAnICsgdGFyZ2V0LmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignIG1vdXNldHJhcCAnKSA+IC0xKSB7XG4gICAgICAgICAgICBzaG91bGRFeGVjdXRlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3ByZXZlbnRJbi5pbmRleE9mKG5vZGVOYW1lKSA+IC0xICYmIGhvdGtleS5hbGxvd0luLm1hcChhbGxvdyA9PiBhbGxvdy50b1VwcGVyQ2FzZSgpKS5pbmRleE9mKG5vZGVOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4ZWN1dGUgY2FsbGJhY2sgaWYgdGhlIGV2ZW50IHdhcyBmaXJlZCBmcm9tIGluc2lkZSBhbiBlbGVtZW50IGxpc3RlZCBpbiBwcmV2ZW50SW4gYnV0IG5vdCBpbiBhbGxvd0luXG4gICAgICAgICAgICBzaG91bGRFeGVjdXRlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZEV4ZWN1dGUpIHtcbiAgICAgICAgICByZXR1cm4gaG90a2V5LmhhbmRsZXIuYXBwbHkodGhpcywgW2V2ZW50LCBjb21ib10pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaG90a2V5LnNwZWNpZmljRXZlbnQpO1xuICB9XG59XG4iLCJpbXBvcnQge0RpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCAnbW91c2V0cmFwJztcclxuXHJcbmltcG9ydCB7SG90S2V5TWFwLCBJSG90a2V5fSBmcm9tICcuL2ludGVyZmFjZXMnO1xyXG5pbXBvcnQge05neEhvdGtleXNTZXJ2aWNlfSBmcm9tICcuL25neC1ob3RrZXlzLnNlcnZpY2UnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdbbmd4SG90a2V5c10nLFxyXG4gIHByb3ZpZGVyczogW05neEhvdGtleXNTZXJ2aWNlXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmd4SG90a2V5c0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcclxuXHJcbiAgQElucHV0KClcclxuICBob3RrZXlzOiBIb3RLZXlNYXBbXTtcclxuXHJcbiAgcHJpdmF0ZSBfbW91c2V0cmFwSW5zdGFuY2U6IE1vdXNldHJhcEluc3RhbmNlO1xyXG4gIHByaXZhdGUgX2hvdGtleXNMaXN0OiBJSG90a2V5W10gPSBbXTtcclxuICBwcml2YXRlIF9vbGRIb3RrZXlzOiBJSG90a2V5W10gPSBbXTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfaG90a2V5c1NlcnZpY2U6IE5neEhvdGtleXNTZXJ2aWNlLCBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XHJcbiAgICB0aGlzLl9tb3VzZXRyYXBJbnN0YW5jZSA9IG5ldyBNb3VzZXRyYXAodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTsgLy8gQmluZCBob3RrZXlzIHRvIHRoZSBjdXJyZW50IGVsZW1lbnQgKGFuZCBhbnkgY2hpbGRyZW4pXHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIGZvciAoY29uc3QgaG90a2V5IG9mIHRoaXMuaG90a2V5cykge1xyXG4gICAgICBjb25zdCBjb21ibyA9IE9iamVjdC5rZXlzKGhvdGtleSlbMF07XHJcbiAgICAgIGNvbnN0IGhvdGtleU9iajogSUhvdGtleSA9IHtcclxuICAgICAgICBjb21ibzogY29tYm8sXHJcbiAgICAgICAgaGFuZGxlcjogaG90a2V5W2NvbWJvXVxyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBmaWx0ZXJlZDogSUhvdGtleVtdID0gdGhpcy5faG90a2V5c1NlcnZpY2UuZ2V0KGNvbWJvKTtcclxuICAgICAgY29uc3Qgb2xkSG90a2V5OiBJSG90a2V5ID0gISFmaWx0ZXJlZCAmJiAhIWZpbHRlcmVkLmxlbmd0aCA/IGZpbHRlcmVkWzBdIDogbnVsbDtcclxuICAgICAgaWYgKG9sZEhvdGtleSAhPT0gbnVsbCkgeyAvLyBXZSBsZXQgdGhlIHVzZXIgb3ZlcndyaXRlIGNhbGxiYWNrcyB0ZW1wb3JhcmlseSBpZiB5b3Ugc3BlY2lmeSBpdCBpbiBIVE1MXHJcbiAgICAgICAgdGhpcy5fb2xkSG90a2V5cy5wdXNoKG9sZEhvdGtleSk7XHJcbiAgICAgICAgdGhpcy5faG90a2V5c1NlcnZpY2UudW5yZWdpc3RlcihvbGRIb3RrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2hvdGtleXNMaXN0LnB1c2goaG90a2V5T2JqKTtcclxuICAgICAgdGhpcy5fbW91c2V0cmFwSW5zdGFuY2UuYmluZChob3RrZXlPYmouY29tYm8sIGhvdGtleU9iai5oYW5kbGVyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgZm9yIChjb25zdCBob3RrZXkgb2YgdGhpcy5faG90a2V5c0xpc3QpIHtcclxuICAgICAgdGhpcy5fbW91c2V0cmFwSW5zdGFuY2UudW5iaW5kKGhvdGtleS5jb21ibyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9ob3RrZXlzU2VydmljZS5yZWdpc3Rlcih0aGlzLl9vbGRIb3RrZXlzKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHtDb21wb25lbnQsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1N1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7Tmd4SG90a2V5c1NlcnZpY2V9IGZyb20gJy4uL25neC1ob3RrZXlzLnNlcnZpY2UnO1xuaW1wb3J0IHtJSG90a2V5fSBmcm9tICcuLi9pbnRlcmZhY2VzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbmd4LWNoZWF0c2hlZXQnLFxuICB0ZW1wbGF0ZVVybDogJy4vbmd4LWNoZWF0c2hlZXQuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9uZ3gtY2hlYXRzaGVldC5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIE5neENoZWF0c2hlZXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgQElucHV0KClcbiAgdGl0bGU6IHN0cmluZztcblxuICBoZWxwVmlzaWJsZSA9IGZhbHNlO1xuICBob3RrZXlzOiBJSG90a2V5W107XG5cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgcHJpdmF0ZSBfbWFwOiBhbnkgPSB7XG4gICAgY29tbWFuZDogJ1xcdTIzMTgnLCAgICAgICAvLyDDosKMwphcbiAgICBzaGlmdDogJ1xcdTIxRTcnLCAgICAgICAgIC8vIMOiwofCp1xuICAgIGxlZnQ6ICdcXHUyMTkwJywgICAgICAgICAgLy8gw6LChsKQXG4gICAgcmlnaHQ6ICdcXHUyMTkyJywgICAgICAgICAvLyDDosKGwpJcbiAgICB1cDogJ1xcdTIxOTEnLCAgICAgICAgICAgIC8vIMOiwobCkVxuICAgIGRvd246ICdcXHUyMTkzJywgICAgICAgICAgLy8gw6LChsKTXG4gICAgJ3JldHVybic6ICdcXHUyM0NFJywgICAgICAvLyDDosKPwo5cbiAgICBiYWNrc3BhY2U6ICdcXHUyMzJCJyAgICAgIC8vIMOiwozCq1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaG90a2V5c1NlcnZpY2U6IE5neEhvdGtleXNTZXJ2aWNlKSB7XG4gICAgdGhpcy50aXRsZSA9IHRoaXMuaG90a2V5c1NlcnZpY2Uub3B0aW9ucy5jaGVhdFNoZWV0VGl0bGU7XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLmhvdGtleXNTZXJ2aWNlLmNoZWF0U2hlZXRUb2dnbGVkXG4gICAgICAuc3Vic2NyaWJlKChpc09wZW4pID0+IHtcbiAgICAgICAgaWYgKGlzT3BlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmhvdGtleXMgPSB0aGlzLmhvdGtleXNTZXJ2aWNlLmhvdGtleXNcbiAgICAgICAgICAgIC5maWx0ZXIoaG90a2V5ID0+IGhvdGtleS5kZXNjcmlwdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNPcGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuaGVscFZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRvZ2dsZUNoZWF0U2hlZXQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICBmb3JtYXRIb3RrZXkoaG90a2V5OiBJSG90a2V5KTogc3RyaW5nW10ge1xuICAgIGlmICghaG90a2V5LmZvcm1hdCkge1xuICAgICAgY29uc3QgY29tYm86IHN0cmluZyA9IEFycmF5LmlzQXJyYXkoaG90a2V5LmNvbWJvKSA/IGhvdGtleS5jb21ib1swXSA6IGhvdGtleS5jb21ibztcbiAgICAgIGNvbnN0IHNlcXVlbmNlOiBzdHJpbmdbXSA9IGNvbWJvLnNwbGl0KC9bXFxzXS8pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZXF1ZW5jZVtpXSA9IHRoaXMuc3ltYm9saXplKHNlcXVlbmNlW2ldKTtcbiAgICAgIH1cbiAgICAgIGhvdGtleS5mb3JtYXQgPSBzZXF1ZW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIGhvdGtleS5mb3JtYXQ7XG4gIH1cblxuICBwcml2YXRlIHN5bWJvbGl6ZShjb21ibzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb21ib1NwbGl0OiBzdHJpbmdbXSA9IGNvbWJvLnNwbGl0KCcrJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21ib1NwbGl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyB0cnkgdG8gcmVzb2x2ZSBjb21tYW5kIC8gY3RybCBiYXNlZCBvbiBPUzpcbiAgICAgIGlmIChjb21ib1NwbGl0W2ldID09PSAnbW9kJykge1xuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ01hYycpID49IDApIHtcbiAgICAgICAgICBjb21ib1NwbGl0W2ldID0gJ2NvbW1hbmQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbWJvU3BsaXRbaV0gPSAnY3RybCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbWJvU3BsaXRbaV0gPSB0aGlzLl9tYXBbY29tYm9TcGxpdFtpXV0gfHwgY29tYm9TcGxpdFtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbWJvU3BsaXQuam9pbignICsgJyk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdG9nZ2xlQ2hlYXRTaGVldCgpOiB2b2lkIHtcbiAgICB0aGlzLmhlbHBWaXNpYmxlID0gIXRoaXMuaGVscFZpc2libGU7XG4gIH1cbn1cbiIsImltcG9ydCB7TW9kdWxlV2l0aFByb3ZpZGVycywgTmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7Tmd4Q2hlYXRzaGVldENvbXBvbmVudH0gZnJvbSAnLi9uZ3gtY2hlYXRzaGVldC9uZ3gtY2hlYXRzaGVldC5jb21wb25lbnQnO1xuaW1wb3J0IHtOZ3hIb3RrZXlzRGlyZWN0aXZlfSBmcm9tICcuL25neC1ob3RrZXlzLmRpcmVjdGl2ZSc7XG5pbXBvcnQge05neEhvdGtleXNTZXJ2aWNlfSBmcm9tICcuL25neC1ob3RrZXlzLnNlcnZpY2UnO1xuaW1wb3J0IHtIb3RrZXlPcHRpb25zfSBmcm9tICcuL3Rva2VuJztcbmltcG9ydCB7SUhvdGtleU9wdGlvbnN9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtOZ3hDaGVhdHNoZWV0Q29tcG9uZW50LCBOZ3hIb3RrZXlzRGlyZWN0aXZlXSxcbiAgZXhwb3J0czogW05neEhvdGtleXNEaXJlY3RpdmUsIE5neENoZWF0c2hlZXRDb21wb25lbnRdLFxuICBwcm92aWRlcnM6IFtOZ3hIb3RrZXlzU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgTmd4SG90a2V5c01vZHVsZSB7XG4gIHN0YXRpYyBmb3JSb290KG9wdGlvbnM/OiBJSG90a2V5T3B0aW9ucyk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xuICAgIHJldHVybiB7XG4gICAgICBuZ01vZHVsZTogTmd4SG90a2V5c01vZHVsZSxcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICBOZ3hIb3RrZXlzU2VydmljZSxcbiAgICAgICAge3Byb3ZpZGU6IEhvdGtleU9wdGlvbnMsIHVzZVZhbHVlOiBvcHRpb25zfVxuICAgICAgXVxuICAgIH07XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFJQSxNQUFhLGFBQWEsR0FBRyxJQUFJLGNBQWMsQ0FBaUIsZUFBZSxDQUFDOzs7Ozs7QUNKaEY7QUFTQSxNQUFNLGVBQWUsR0FBbUI7SUFDdEMsaUJBQWlCLEVBQUUsS0FBSztJQUN4QixlQUFlLEVBQUUscUJBQXFCO0lBQ3RDLGdCQUFnQixFQUFFLEdBQUc7SUFDckIsMkJBQTJCLEVBQUUsNEJBQTRCO0lBQ3pELGtCQUFrQixFQUFFLEtBQUs7SUFDekIsNkJBQTZCLEVBQUUscUJBQXFCO0NBQ3JELENBQUM7QUFHRjs7OztJQVNFLFlBQTJDLFFBQXdCO1FBQXhCLGFBQVEsR0FBUixRQUFRLENBQWdCO2tDQU54QixJQUFJLEdBQUcsRUFBRTs4QkFDYixJQUFJLEdBQUcsRUFBRTtrQ0FFTCxJQUFJLE9BQU8sRUFBRTswQkFDbkMsQ0FBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLFVBQVUsQ0FBQztRQUdsRCxJQUFJLENBQUMsZUFBZSxHQUFHLE1BQU0s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