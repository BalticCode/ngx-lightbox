/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { Inject, Injectable } from '@angular/core';
import { Subject } from 'rxjs';
import 'mousetrap';
import { HotkeyOptions } from './token';
import { share } from 'rxjs/internal/operators';
/** @type {?} */
const _defaultOptions = {
    disableCheatSheet: false,
    cheatSheetTitle: 'Keyboard Shortcuts:',
    cheatSheetHotkey: '?',
    cheatSheetHotkeyDescription: 'Show / hide this help menu',
    cheatSheetCloseEsc: false,
    cheatSheetCloseEscDescription: 'Hide this help menu'
};
export class NgxHotkeysService {
    /**
     * @param {?} _options
     */
    constructor(_options) {
        this._options = _options;
        this._registeredHotkeys = new Set();
        this._pausedHotkeys = new Set();
        this._cheatSheetToggled = new Subject();
        this._preventIn = ['INPUT', 'SELECT', 'TEXTAREA'];
        this._serviceOptions = Object.assign(_defaultOptions, this._options);
        Mousetrap.prototype.stopCallback = (event, element, combo, callback) => {
            // if the element has the class "mousetrap" then no need to stop
            if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
                return false;
            }
            return (element.contentEditable && element.contentEditable === 'true');
        };
        this._mousetrapInstance = new (/** @type {?} */ (Mousetrap))();
        if (!this._serviceOptions.disableCheatSheet) {
            this.register({
                combo: this._serviceOptions.cheatSheetHotkey,
                handler: function (event) {
                    this._cheatSheetToggled.next();
                }.bind(this),
                description: this._serviceOptions.cheatSheetHotkeyDescription
            });
        }
        if (this._serviceOptions.cheatSheetCloseEsc) {
            this.register({
                combo: 'esc',
                handler: function (event) {
                    this._cheatSheetToggled.next(false);
                }.bind(this),
                allowIn: ['HOTKEYS-CHEATSHEET'],
                description: this._serviceOptions.cheatSheetCloseEscDescription
            });
        }
    }
    /**
     * Returns the registered hotkeys as array.
     * @return {?} all registered hotkeys
     */
    get hotkeys() {
        return Array.from(this._registeredHotkeys);
    }
    /**
     * Returns an Observable stream indicating the cheatsheets visibility was toggled.
     * @return {?} stream indicating the cheatsheets visibility was toggled
     */
    get cheatSheetToggled() {
        return this._cheatSheetToggled.asObservable().pipe(share());
    }
    /**
     * @return {?}
     */
    get options() {
        return this._serviceOptions;
    }
    /**
     * Registers a new hotkey/new hotkeys with it's/their handler(s).
     * @param {?} hotkey hotkeys to listen for
     * @param {?=} unpausing flag indicating if the hotkeys should be unpaused
     * @return {?}
     */
    register(hotkey, unpausing = false) {
        /** @type {?} */
        let hotkeys = [].concat(hotkey);
        if (unpausing) {
            hotkeys = Array.from(this._pausedHotkeys);
        }
        hotkeys.forEach(h => {
            if (unpausing) {
                this._pausedHotkeys.delete(h);
            }
            this._registeredHotkeys.add(h);
            this.bindToMoustrap(h);
        });
    }
    /**
     * Removes a/the registered hotkey(s).
     * @param {?} hotkey hotkey filter
     * @param {?=} pausing flag indicating if the hotkeys should be paused
     * @return {?}
     */
    unregister(hotkey, pausing = false) {
        /** @type {?} */
        const hotkeys = [].concat(hotkey);
        hotkeys.forEach(h => {
            this._registeredHotkeys.delete(h);
            if (pausing) {
                this._pausedHotkeys.add(h);
            }
            this._mousetrapInstance.unbind(h.combo, h.specificEvent);
        });
    }
    /**
     * Returns all hotkeys matching the passed combo(s).
     * @param {?=} combo combo to match against
     * @return {?} all matched hotkeys
     */
    get(combo) {
        return this.hotkeys.filter(h => h.combo === combo);
    }
    /**
     * Stops listening for the specified hotkeys.
     * @param {?=} hotkey hotkey filter
     * @return {?}
     */
    pause(hotkey) {
        if (!hotkey) {
            return this.pause(this.hotkeys);
        }
        /** @type {?} */
        const hotkeys = [].concat(hotkey);
        this.unregister(hotkeys, true);
    }
    /**
     * Resumes listening for the specified hotkeys.
     * @param {?=} hotkey hotkey filter
     * @return {?}
     */
    unpause(hotkey) {
        if (!hotkey) {
            return this.unpause(this.hotkeys);
        }
        /** @type {?} */
        const hotkeys = [].concat(hotkey);
        this.register(hotkeys, true);
    }
    /**
     * Resets all hotkeys.
     * @return {?}
     */
    reset() {
        this._mousetrapInstance.reset();
        this._registeredHotkeys.clear();
        this._pausedHotkeys.clear();
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.reset();
    }
    /**
     * @param {?} hotkey
     * @return {?}
     */
    bindToMoustrap(hotkey) {
        this._mousetrapInstance.bind(hotkey.combo, (event, combo) => {
            /** @type {?} */
            let shouldExecute = true;
            // if the callback is executed directly `hotkey.get('w').callback()`
            // there will be no event, so just execute the callback.
            if (event) {
                /** @type {?} */
                const target = /** @type {?} */ ((event.target || event.srcElement));
                /** @type {?} */
                const nodeName = target.nodeName.toUpperCase();
                // check if the input has a mousetrap class, and skip checking preventIn if so
                if ((' ' + target.className + ' ').indexOf(' mousetrap ') > -1) {
                    shouldExecute = true;
                }
                else if (this._preventIn.indexOf(nodeName) > -1 && hotkey.allowIn.map(allow => allow.toUpperCase()).indexOf(nodeName) === -1) {
                    // don't execute callback if the event was fired from inside an element listed in preventIn but not in allowIn
                    shouldExecute = false;
                }
            }
            if (shouldExecute) {
                return hotkey.handler.apply(this, [event, combo]);
            }
        }, hotkey.specificEvent);
    }
}
NgxHotkeysService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
NgxHotkeysService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [HotkeyOptions,] }] }
];
if (false) {
    /** @type {?} */
    NgxHotkeysService.prototype._serviceOptions;
    /** @type {?} */
    NgxHotkeysService.prototype._registeredHotkeys;
    /** @type {?} */
    NgxHotkeysService.prototype._pausedHotkeys;
    /** @type {?} */
    NgxHotkeysService.prototype._mousetrapInstance;
    /** @type {?} */
    NgxHotkeysService.prototype._cheatSheetToggled;
    /** @type {?} */
    NgxHotkeysService.prototype._preventIn;
    /** @type {?} */
    NgxHotkeysService.prototype._options;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWhvdGtleXMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BiYWx0aWNjb2RlL25neC1ob3RrZXlzLyIsInNvdXJjZXMiOlsibGliL25neC1ob3RrZXlzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxNQUFNLEVBQUUsVUFBVSxFQUFZLE1BQU0sZUFBZSxDQUFDO0FBQzVELE9BQU8sRUFBYSxPQUFPLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFFekMsT0FBTyxXQUFXLENBQUM7QUFHbkIsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUN0QyxPQUFPLEVBQUMsS0FBSyxFQUFDLE1BQU0seUJBQXlCLENBQUM7O0FBRTlDLE1BQU0sZUFBZSxHQUFtQjtJQUN0QyxpQkFBaUIsRUFBRSxLQUFLO0lBQ3hCLGVBQWUsRUFBRSxxQkFBcUI7SUFDdEMsZ0JBQWdCLEVBQUUsR0FBRztJQUNyQiwyQkFBMkIsRUFBRSw0QkFBNEI7SUFDekQsa0JBQWtCLEVBQUUsS0FBSztJQUN6Qiw2QkFBNkIsRUFBRSxxQkFBcUI7Q0FDckQsQ0FBQztBQUdGLE1BQU07Ozs7SUFTSixZQUEyQyxRQUF3QjtRQUF4QixhQUFRLEdBQVIsUUFBUSxDQUFnQjtrQ0FOeEIsSUFBSSxHQUFHLEVBQUU7OEJBQ2IsSUFBSSxHQUFHLEVBQUU7a0NBRUwsSUFBSSxPQUFPLEVBQUU7MEJBQ25DLENBQUMsT0FBTyxFQUFFLFFBQVEsRUFBRSxVQUFVLENBQUM7UUFHbEQsSUFBSSxDQUFDLGVBQWUsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLGVBQWUsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDckUsU0FBUyxDQUFDLFNBQVMsQ0FBQyxZQUFZLEdBQUcsQ0FBQyxLQUFvQixFQUFFLE9BQW9CLEVBQUUsS0FBYSxFQUFFLFFBQWtCLEVBQUUsRUFBRTs7WUFFbkgsSUFBSSxDQUFDLEdBQUcsR0FBRyxPQUFPLENBQUMs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O1lBQ3RDLElBQUksYUFBYSxHQUFHLElBQUksQ0FBQzs7O1lBSXpCLElBQUksS0FBSyxFQUFFOztnQkFDVCxNQUFNLE1BQU0scUJBQTZCLENBQUMsS0FBSyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLEVBQUM7O2dCQUM1RSxNQUFNLFFBQVEsR0FBVyxNQUFNLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDOztnQkFHdkQsSUFBSSxDQUFDLEdBQUcsR0FBRyxNQUFNLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtvQkFDOUQsYUFBYSxHQUFHLElBQUksQ0FBQztpQkFDdEI7cUJBQU0sSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTs7b0JBRTlILGFBQWEsR0FBRyxLQUFLLENBQUM7aUJBQ3ZCO2FBQ0Y7WUFFRCxJQUFJLGFBQWEsRUFBRTtnQkFDakIsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQzthQUNuRDtTQUNGLEVBQ0QsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDOzs7O1lBM0szQixVQUFVOzs7OzRDQVVJLE1BQU0sU0FBQyxhQUFhIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtJbmplY3QsIEluamVjdGFibGUsIE9uRGVzdHJveX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge09ic2VydmFibGUsIFN1YmplY3R9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgJ21vdXNldHJhcCc7XG5cbmltcG9ydCB7SUhvdGtleSwgSUhvdGtleU9wdGlvbnN9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQge0hvdGtleU9wdGlvbnN9IGZyb20gJy4vdG9rZW4nO1xuaW1wb3J0IHtzaGFyZX0gZnJvbSAncnhqcy9pbnRlcm5hbC9vcGVyYXRvcnMnO1xuXG5jb25zdCBfZGVmYXVsdE9wdGlvbnM6IElIb3RrZXlPcHRpb25zID0ge1xuICBkaXNhYmxlQ2hlYXRTaGVldDogZmFsc2UsXG4gIGNoZWF0U2hlZXRUaXRsZTogJ0tleWJvYXJkIFNob3J0Y3V0czonLFxuICBjaGVhdFNoZWV0SG90a2V5OiAnPycsXG4gIGNoZWF0U2hlZXRIb3RrZXlEZXNjcmlwdGlvbjogJ1Nob3cgLyBoaWRlIHRoaXMgaGVscCBtZW51JyxcbiAgY2hlYXRTaGVldENsb3NlRXNjOiBmYWxzZSxcbiAgY2hlYXRTaGVldENsb3NlRXNjRGVzY3JpcHRpb246ICdIaWRlIHRoaXMgaGVscCBtZW51J1xufTtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5neEhvdGtleXNTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICBwcml2YXRlIF9zZXJ2aWNlT3B0aW9uczogSUhvdGtleU9wdGlvbnM7XG4gIHByaXZhdGUgX3JlZ2lzdGVyZWRIb3RrZXlzOiBTZXQ8SUhvdGtleT4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgX3BhdXNlZEhvdGtleXM6IFNldDxJSG90a2V5PiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBfbW91c2V0cmFwSW5zdGFuY2U6IE1vdXNldHJhcEluc3RhbmNlO1xuICBwcml2YXRlIF9jaGVhdFNoZWV0VG9nZ2xlZDogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3QoKTtcbiAgcHJpdmF0ZSBfcHJldmVudEluID0gWydJTlBVVCcsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXTtcblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KEhvdGtleU9wdGlvbnMpIHByaXZhdGUgX29wdGlvbnM6IElIb3RrZXlPcHRpb25zKSB7XG4gICAgdGhpcy5fc2VydmljZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKF9kZWZhdWx0T3B0aW9ucywgdGhpcy5fb3B0aW9ucyk7XG4gICAgTW91c2V0cmFwLnByb3RvdHlwZS5zdG9wQ2FsbGJhY2sgPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBjb21ibzogc3RyaW5nLCBjYWxsYmFjazogRnVuY3Rpb24pID0+IHtcbiAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3MgXCJtb3VzZXRyYXBcIiB0aGVuIG5vIG5lZWQgdG8gc3RvcFxuICAgICAgaWYgKCgnICcgKyBlbGVtZW50LmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignIG1vdXNldHJhcCAnKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoZWxlbWVudC5jb250ZW50RWRpdGFibGUgJiYgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG4gICAgfTtcbiAgICB0aGlzLl9tb3VzZXRyYXBJbnN0YW5jZSA9IG5ldyAoPGFueT5Nb3VzZXRyYXApKCk7XG4gICAgaWYgKCF0aGlzLl9zZXJ2aWNlT3B0aW9ucy5kaXNhYmxlQ2hlYXRTaGVldCkge1xuICAgICAgdGhpcy5yZWdpc3Rlcih7XG4gICAgICAgIGNvbWJvOiB0aGlzLl9zZXJ2aWNlT3B0aW9ucy5jaGVhdFNoZWV0SG90a2V5LFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICB0aGlzLl9jaGVhdFNoZWV0VG9nZ2xlZC5uZXh0KCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuX3NlcnZpY2VPcHRpb25zLmNoZWF0U2hlZXRIb3RrZXlEZXNjcmlwdGlvblxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlcnZpY2VPcHRpb25zLmNoZWF0U2hlZXRDbG9zZUVzYykge1xuICAgICAgdGhpcy5yZWdpc3Rlcih7XG4gICAgICAgIGNvbWJvOiAnZXNjJyxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgICAgdGhpcy5fY2hlYXRTaGVldFRvZ2dsZWQubmV4dChmYWxzZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgYWxsb3dJbjogWydIT1RLRVlTLUNIRUFUU0hFRVQnXSxcbiAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuX3NlcnZpY2VPcHRpb25zLmNoZWF0U2hlZXRDbG9zZUVzY0Rlc2NyaXB0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVnaXN0ZXJlZCBob3RrZXlzIGFzIGFycmF5LlxuICAgKiBAcmV0dXJucyBhbGwgcmVnaXN0ZXJlZCBob3RrZXlzXG4gICAqL1xuICBwdWJsaWMgZ2V0IGhvdGtleXMoKTogSUhvdGtleVtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9yZWdpc3RlcmVkSG90a2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHN0cmVhbSBpbmRpY2F0aW5nIHRoZSBjaGVhdHNoZWV0cyB2aXNpYmlsaXR5IHdhcyB0b2dnbGVkLlxuICAgKiBAcmV0dXJucyBzdHJlYW0gaW5kaWNhdGluZyB0aGUgY2hlYXRzaGVldHMgdmlzaWJpbGl0eSB3YXMgdG9nZ2xlZFxuICAgKi9cbiAgcHVibGljIGdldCBjaGVhdFNoZWV0VG9nZ2xlZCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fY2hlYXRTaGVldFRvZ2dsZWQuYXNPYnNlcnZhYmxlKCkucGlwZShcbiAgICAgIHNoYXJlKClcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGdldCBvcHRpb25zKCk6IElIb3RrZXlPcHRpb25zIHtcbiAgICByZXR1cm4gdGhpcy5fc2VydmljZU9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbmV3IGhvdGtleS9uZXcgaG90a2V5cyB3aXRoIGl0J3MvdGhlaXIgaGFuZGxlcihzKS5cbiAgICogQHBhcmFtIGhvdGtleSBob3RrZXlzIHRvIGxpc3RlbiBmb3JcbiAgICogQHBhcmFtIHVucGF1c2luZyBmbGFnIGluZGljYXRpbmcgaWYgdGhlIGhvdGtleXMgc2hvdWxkIGJlIHVucGF1c2VkXG4gICAqL1xuICBwdWJsaWMgcmVnaXN0ZXIoaG90a2V5OiBJSG90a2V5IHwgSUhvdGtleVtdLCB1bnBhdXNpbmcgPSBmYWxzZSk6IHZvaWQge1xuICAgIGxldCBob3RrZXlzOiBJSG90a2V5W10gPSBbXS5jb25jYXQoaG90a2V5KTtcbiAgICBpZiAodW5wYXVzaW5nKSB7XG4gICAgICBob3RrZXlzID0gQXJyYXkuZnJvbSh0aGlzLl9wYXVzZWRIb3RrZXlzKTtcbiAgICB9XG4gICAgaG90a2V5cy5mb3JFYWNoKGggPT4ge1xuICAgICAgaWYgKHVucGF1c2luZykge1xuICAgICAgICB0aGlzLl9wYXVzZWRIb3RrZXlzLmRlbGV0ZShoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlZ2lzdGVyZWRIb3RrZXlzLmFkZChoKTtcbiAgICAgIHRoaXMuYmluZFRvTW91c3RyYXAoaCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhL3RoZSByZWdpc3RlcmVkIGhvdGtleShzKS5cbiAgICogQHBhcmFtIGhvdGtleSBob3RrZXkgZmlsdGVyXG4gICAqIEBwYXJhbSBwYXVzaW5nIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgaG90a2V5cyBzaG91bGQgYmUgcGF1c2VkXG4gICAqL1xuICBwdWJsaWMgdW5yZWdpc3Rlcihob3RrZXk6IElIb3RrZXkgfCBJSG90a2V5W10sIHBhdXNpbmcgPSBmYWxzZSk6IHZvaWQge1xuICAgIGNvbnN0IGhvdGtleXM6IElIb3RrZXlbXSA9IFtdLmNvbmNhdChob3RrZXkpO1xuXG4gICAgaG90a2V5cy5mb3JFYWNoKGggPT4ge1xuICAgICAgdGhpcy5fcmVnaXN0ZXJlZEhvdGtleXMuZGVsZXRlKGgpO1xuICAgICAgaWYgKHBhdXNpbmcpIHtcbiAgICAgICAgdGhpcy5fcGF1c2VkSG90a2V5cy5hZGQoaCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tb3VzZXRyYXBJbnN0YW5jZS51bmJpbmQoaC5jb21ibywgaC5zcGVjaWZpY0V2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBob3RrZXlzIG1hdGNoaW5nIHRoZSBwYXNzZWQgY29tYm8ocykuXG4gICAqIEBwYXJhbSBjb21ibyBjb21ibyB0byBtYXRjaCBhZ2FpbnN0XG4gICAqIEByZXR1cm5zIGFsbCBtYXRjaGVkIGhvdGtleXNcbiAgICovXG4gIHB1YmxpYyBnZXQoY29tYm8/OiBzdHJpbmcgfCBzdHJpbmdbXSk6IElIb3RrZXlbXSB7XG4gICAgcmV0dXJuIHRoaXMuaG90a2V5cy5maWx0ZXIoaCA9PiBoLmNvbWJvID09PSBjb21ibyk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgbGlzdGVuaW5nIGZvciB0aGUgc3BlY2lmaWVkIGhvdGtleXMuXG4gICAqIEBwYXJhbSBob3RrZXkgaG90a2V5IGZpbHRlclxuICAgKi9cbiAgcHVibGljIHBhdXNlKGhvdGtleT86IElIb3RrZXkgfCBJSG90a2V5W10pOiB2b2lkIHtcbiAgICBpZiAoIWhvdGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMucGF1c2UodGhpcy5ob3RrZXlzKTtcbiAgICB9XG4gICAgY29uc3QgaG90a2V5czogSUhvdGtleVtdID0gW10uY29uY2F0KGhvdGtleSk7XG4gICAgdGhpcy51bnJlZ2lzdGVyKGhvdGtleXMsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZXMgbGlzdGVuaW5nIGZvciB0aGUgc3BlY2lmaWVkIGhvdGtleXMuXG4gICAqIEBwYXJhbSBob3RrZXkgaG90a2V5IGZpbHRlclxuICAgKi9cbiAgcHVibGljIHVucGF1c2UoaG90a2V5PzogSUhvdGtleSB8IElIb3RrZXlbXSk6IHZvaWQge1xuICAgIGlmICghaG90a2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy51bnBhdXNlKHRoaXMuaG90a2V5cyk7XG4gICAgfVxuICAgIGNvbnN0IGhvdGtleXM6IElIb3RrZXlbXSA9IFtdLmNvbmNhdChob3RrZXkpO1xuICAgIHRoaXMucmVnaXN0ZXIoaG90a2V5cywgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIGFsbCBob3RrZXlzLlxuICAgKi9cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuX21vdXNldHJhcEluc3RhbmNlLnJlc2V0KCk7XG4gICAgdGhpcy5fcmVnaXN0ZXJlZEhvdGtleXMuY2xlYXIoKTtcbiAgICB0aGlzLl9wYXVzZWRIb3RrZXlzLmNsZWFyKCk7XG4gIH1cblxuICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBiaW5kVG9Nb3VzdHJhcChob3RrZXk6IElIb3RrZXkpOiB2b2lkIHtcblxuICAgIHRoaXMuX21vdXNldHJhcEluc3RhbmNlLmJpbmQoaG90a2V5LmNvbWJvLFxuICAgICAgKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBjb21ibzogc3RyaW5nKSA9PiB7XG4gICAgICAgIGxldCBzaG91bGRFeGVjdXRlID0gdHJ1ZTtcblxuICAgICAgICAvLyBpZiB0aGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgZGlyZWN0bHkgYGhvdGtleS5nZXQoJ3cnKS5jYWxsYmFjaygpYFxuICAgICAgICAvLyB0aGVyZSB3aWxsIGJlIG5vIGV2ZW50LCBzbyBqdXN0IGV4ZWN1dGUgdGhlIGNhbGxiYWNrLlxuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXQ6IEhUTUxFbGVtZW50ID0gPEhUTUxFbGVtZW50PihldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudCk7IC8vIHNyY0VsZW1lbnQgaXMgSUUgb25seVxuICAgICAgICAgIGNvbnN0IG5vZGVOYW1lOiBzdHJpbmcgPSB0YXJnZXQubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBpbnB1dCBoYXMgYSBtb3VzZXRyYXAgY2xhc3MsIGFuZCBza2lwIGNoZWNraW5nIHByZXZlbnRJbiBpZiBzb1xuICAgICAgICAgIGlmICgoJyAnICsgdGFyZ2V0LmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignIG1vdXNldHJhcCAnKSA+IC0xKSB7XG4gICAgICAgICAgICBzaG91bGRFeGVjdXRlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3ByZXZlbnRJbi5pbmRleE9mKG5vZGVOYW1lKSA+IC0xICYmIGhvdGtleS5hbGxvd0luLm1hcChhbGxvdyA9PiBhbGxvdy50b1VwcGVyQ2FzZSgpKS5pbmRleE9mKG5vZGVOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4ZWN1dGUgY2FsbGJhY2sgaWYgdGhlIGV2ZW50IHdhcyBmaXJlZCBmcm9tIGluc2lkZSBhbiBlbGVtZW50IGxpc3RlZCBpbiBwcmV2ZW50SW4gYnV0IG5vdCBpbiBhbGxvd0luXG4gICAgICAgICAgICBzaG91bGRFeGVjdXRlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZEV4ZWN1dGUpIHtcbiAgICAgICAgICByZXR1cm4gaG90a2V5LmhhbmRsZXIuYXBwbHkodGhpcywgW2V2ZW50LCBjb21ib10pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaG90a2V5LnNwZWNpZmljRXZlbnQpO1xuICB9XG59XG4iXX0=