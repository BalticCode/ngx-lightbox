/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { Inject, Injectable } from '@angular/core';
import { Subject } from 'rxjs';
import 'mousetrap';
import { HotkeyOptions } from './token';
import { share } from 'rxjs/internal/operators';
/** @type {?} */
var _defaultOptions = {
    disableCheatSheet: false,
    cheatSheetTitle: 'Keyboard Shortcuts:',
    cheatSheetHotkey: '?',
    cheatSheetHotkeyDescription: 'Show / hide this help menu',
    cheatSheetCloseEsc: false,
    cheatSheetCloseEscDescription: 'Hide this help menu'
};
var NgxHotkeysService = /** @class */ (function () {
    function NgxHotkeysService(_options) {
        this._options = _options;
        this._registeredHotkeys = new Set();
        this._pausedHotkeys = new Set();
        this._cheatSheetToggled = new Subject();
        this._preventIn = ['INPUT', 'SELECT', 'TEXTAREA'];
        this._serviceOptions = Object.assign(_defaultOptions, this._options);
        Mousetrap.prototype.stopCallback = function (event, element, combo, callback) {
            // if the element has the class "mousetrap" then no need to stop
            if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
                return false;
            }
            return (element.contentEditable && element.contentEditable === 'true');
        };
        this._mousetrapInstance = new (/** @type {?} */ (Mousetrap))();
        if (!this._serviceOptions.disableCheatSheet) {
            this.register({
                combo: this._serviceOptions.cheatSheetHotkey,
                handler: function (event) {
                    this._cheatSheetToggled.next();
                }.bind(this),
                description: this._serviceOptions.cheatSheetHotkeyDescription
            });
        }
        if (this._serviceOptions.cheatSheetCloseEsc) {
            this.register({
                combo: 'esc',
                handler: function (event) {
                    this._cheatSheetToggled.next(false);
                }.bind(this),
                allowIn: ['HOTKEYS-CHEATSHEET'],
                description: this._serviceOptions.cheatSheetCloseEscDescription
            });
        }
    }
    Object.defineProperty(NgxHotkeysService.prototype, "hotkeys", {
        get: /**
         * Returns the registered hotkeys as array.
         * @return {?} all registered hotkeys
         */
        function () {
            return Array.from(this._registeredHotkeys);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxHotkeysService.prototype, "cheatSheetToggled", {
        get: /**
         * Returns an Observable stream indicating the cheatsheets visibility was toggled.
         * @return {?} stream indicating the cheatsheets visibility was toggled
         */
        function () {
            return this._cheatSheetToggled.asObservable().pipe(share());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgxHotkeysService.prototype, "options", {
        get: /**
         * @return {?}
         */
        function () {
            return this._serviceOptions;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Registers a new hotkey/new hotkeys with it's/their handler(s).
     * @param {?} hotkey hotkeys to listen for
     * @param {?=} unpausing flag indicating if the hotkeys should be unpaused
     * @return {?}
     */
    NgxHotkeysService.prototype.register = /**
     * Registers a new hotkey/new hotkeys with it's/their handler(s).
     * @param {?} hotkey hotkeys to listen for
     * @param {?=} unpausing flag indicating if the hotkeys should be unpaused
     * @return {?}
     */
    function (hotkey, unpausing) {
        var _this = this;
        if (unpausing === void 0) { unpausing = false; }
        /** @type {?} */
        var hotkeys = [].concat(hotkey);
        if (unpausing) {
            hotkeys = Array.from(this._pausedHotkeys);
        }
        hotkeys.forEach(function (h) {
            if (unpausing) {
                _this._pausedHotkeys.delete(h);
            }
            _this._registeredHotkeys.add(h);
            _this.bindToMoustrap(h);
        });
    };
    /**
     * Removes a/the registered hotkey(s).
     * @param {?} hotkey hotkey filter
     * @param {?=} pausing flag indicating if the hotkeys should be paused
     * @return {?}
     */
    NgxHotkeysService.prototype.unregister = /**
     * Removes a/the registered hotkey(s).
     * @param {?} hotkey hotkey filter
     * @param {?=} pausing flag indicating if the hotkeys should be paused
     * @return {?}
     */
    function (hotkey, pausing) {
        var _this = this;
        if (pausing === void 0) { pausing = false; }
        /** @type {?} */
        var hotkeys = [].concat(hotkey);
        hotkeys.forEach(function (h) {
            _this._registeredHotkeys.delete(h);
            if (pausing) {
                _this._pausedHotkeys.add(h);
            }
            _this._mousetrapInstance.unbind(h.combo, h.specificEvent);
        });
    };
    /**
     * Returns all hotkeys matching the passed combo(s).
     * @param {?=} combo combo to match against
     * @return {?} all matched hotkeys
     */
    NgxHotkeysService.prototype.get = /**
     * Returns all hotkeys matching the passed combo(s).
     * @param {?=} combo combo to match against
     * @return {?} all matched hotkeys
     */
    function (combo) {
        return this.hotkeys.filter(function (h) { return h.combo === combo; });
    };
    /**
     * Stops listening for the specified hotkeys.
     * @param {?=} hotkey hotkey filter
     * @return {?}
     */
    NgxHotkeysService.prototype.pause = /**
     * Stops listening for the specified hotkeys.
     * @param {?=} hotkey hotkey filter
     * @return {?}
     */
    function (hotkey) {
        if (!hotkey) {
            return this.pause(this.hotkeys);
        }
        /** @type {?} */
        var hotkeys = [].concat(hotkey);
        this.unregister(hotkeys, true);
    };
    /**
     * Resumes listening for the specified hotkeys.
     * @param {?=} hotkey hotkey filter
     * @return {?}
     */
    NgxHotkeysService.prototype.unpause = /**
     * Resumes listening for the specified hotkeys.
     * @param {?=} hotkey hotkey filter
     * @return {?}
     */
    function (hotkey) {
        if (!hotkey) {
            return this.unpause(this.hotkeys);
        }
        /** @type {?} */
        var hotkeys = [].concat(hotkey);
        this.register(hotkeys, true);
    };
    /**
     * Resets all hotkeys.
     * @return {?}
     */
    NgxHotkeysService.prototype.reset = /**
     * Resets all hotkeys.
     * @return {?}
     */
    function () {
        this._mousetrapInstance.reset();
        this._registeredHotkeys.clear();
        this._pausedHotkeys.clear();
    };
    /**
     * @return {?}
     */
    NgxHotkeysService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.reset();
    };
    /**
     * @param {?} hotkey
     * @return {?}
     */
    NgxHotkeysService.prototype.bindToMoustrap = /**
     * @param {?} hotkey
     * @return {?}
     */
    function (hotkey) {
        var _this = this;
        this._mousetrapInstance.bind(hotkey.combo, function (event, combo) {
            /** @type {?} */
            var shouldExecute = true;
            // if the callback is executed directly `hotkey.get('w').callback()`
            // there will be no event, so just execute the callback.
            if (event) {
                /** @type {?} */
                var target = /** @type {?} */ ((event.target || event.srcElement));
                /** @type {?} */
                var nodeName = target.nodeName.toUpperCase();
                // check if the input has a mousetrap class, and skip checking preventIn if so
                if ((' ' + target.className + ' ').indexOf(' mousetrap ') > -1) {
                    shouldExecute = true;
                }
                else if (_this._preventIn.indexOf(nodeName) > -1 && hotkey.allowIn.map(function (allow) { return allow.toUpperCase(); }).indexOf(nodeName) === -1) {
                    // don't execute callback if the event was fired from inside an element listed in preventIn but not in allowIn
                    shouldExecute = false;
                }
            }
            if (shouldExecute) {
                return hotkey.handler.apply(_this, [event, combo]);
            }
        }, hotkey.specificEvent);
    };
    NgxHotkeysService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    NgxHotkeysService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [HotkeyOptions,] }] }
    ]; };
    return NgxHotkeysService;
}());
export { NgxHotkeysService };
if (false) {
    /** @type {?} */
    NgxHotkeysService.prototype._serviceOptions;
    /** @type {?} */
    NgxHotkeysService.prototype._registeredHotkeys;
    /** @type {?} */
    NgxHotkeysService.prototype._pausedHotkeys;
    /** @type {?} */
    NgxHotkeysService.prototype._mousetrapInstance;
    /** @type {?} */
    NgxHotkeysService.prototype._cheatSheetToggled;
    /** @type {?} */
    NgxHotkeysService.prototype._preventIn;
    /** @type {?} */
    NgxHotkeysService.prototype._options;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LWhvdGtleXMuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BiYWx0aWNjb2RlL25neC1ob3RrZXlzLyIsInNvdXJjZXMiOlsibGliL25neC1ob3RrZXlzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxNQUFNLEVBQUUsVUFBVSxFQUFZLE1BQU0sZUFBZSxDQUFDO0FBQzVELE9BQU8sRUFBYSxPQUFPLEVBQUMsTUFBTSxNQUFNLENBQUM7QUFFekMsT0FBTyxXQUFXLENBQUM7QUFHbkIsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUN0QyxPQUFPLEVBQUMsS0FBSyxFQUFDLE1BQU0seUJBQXlCLENBQUM7O0FBRTlDLElBQU0sZUFBZSxHQUFtQjtJQUN0QyxpQkFBaUIsRUFBRSxLQUFLO0lBQ3hCLGVBQWUsRUFBRSxxQkFBcUI7SUFDdEMsZ0JBQWdCLEVBQUUsR0FBRztJQUNyQiwyQkFBMkIsRUFBRSw0QkFBNEI7SUFDekQsa0JBQWtCLEVBQUUsS0FBSztJQUN6Qiw2QkFBNkIsRUFBRSxxQkFBcUI7Q0FDckQsQ0FBQzs7SUFZQSwyQkFBMkMsUUFBd0I7UUFBeEIsYUFBUSxHQUFSLFFBQVEsQ0FBZ0I7a0NBTnhCLElBQUksR0FBRyxFQUFFOzhCQUNiLElBQUksR0FBRyxFQUFFO2tDQUVMLElBQUksT0FBTyxFQUFFOzBCQUNuQyxDQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsVUFBVSxDQUFDO1FBR2xELElBQUksQ0FBQyxlQUFlLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxlQUFlLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ3JFLFNBQVMsQ0FBQyxTQUFTLENBQUMsWUFBWSxHQUFHLFVBQUMsS0FBb0IsRUFBRSxPQUFvQixFQUFFLEtBQWEsRUFBRSxRQUFrQjs7WUFFL0csSUFBSSxDQUFDLEdBQUcsR0FBRyxPQUFPLENBQUMsU0FBUyxHQUFHLEdBQUcsQ0FBQyxD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QUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQ3ZDLFVBQUMsS0FBb0IsRUFBRSxLQUFhOztZQUNsQyxJQUFJLGFBQWEsR0FBRyxJQUFJLENBQUM7OztZQUl6QixJQUFJLEtBQUssRUFBRTs7Z0JBQ1QsSUFBTSxNQUFNLHFCQUE2QixDQUFDLEtBQUssQ0FBQyxNQUFNLElBQUksS0FBSyxDQUFDLFVBQVUsQ0FBQyxFQUFDOztnQkFDNUUsSUFBTSxRQUFRLEdBQVcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQzs7Z0JBR3ZELElBQUksQ0FBQyxHQUFHLEdBQUcsTUFBTSxDQUFDLFNBQVMsR0FBRyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUU7b0JBQzlELGFBQWEsR0FBRyxJQUFJLENBQUM7aUJBQ3RCO3FCQUFNLElBQUksS0FBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBQSxLQUFLLElBQUksT0FBQSxLQUFLLENBQUMsV0FBVyxFQUFFLEVBQW5CLENBQW1CLENBQUMsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7O29CQUU5SCxhQUFhLEdBQUcsS0FBSyxDQUFDO2lCQUN2QjthQUNGO1lBRUQsSUFBSSxhQUFhLEVBQUU7Z0JBQ2pCLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSSxFQUFFLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7YUFDbkQ7U0FDRixFQUNELE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQzs7O2dCQTNLM0IsVUFBVTs7OztnREFVSSxNQUFNLFNBQUMsYUFBYTs7NEJBNUJuQzs7U0FtQmEsaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtJbmplY3QsIEluamVjdGFibGUsIE9uRGVzdHJveX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge09ic2VydmFibGUsIFN1YmplY3R9IGZyb20gJ3J4anMnO1xuXG5pbXBvcnQgJ21vdXNldHJhcCc7XG5cbmltcG9ydCB7SUhvdGtleSwgSUhvdGtleU9wdGlvbnN9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5pbXBvcnQge0hvdGtleU9wdGlvbnN9IGZyb20gJy4vdG9rZW4nO1xuaW1wb3J0IHtzaGFyZX0gZnJvbSAncnhqcy9pbnRlcm5hbC9vcGVyYXRvcnMnO1xuXG5jb25zdCBfZGVmYXVsdE9wdGlvbnM6IElIb3RrZXlPcHRpb25zID0ge1xuICBkaXNhYmxlQ2hlYXRTaGVldDogZmFsc2UsXG4gIGNoZWF0U2hlZXRUaXRsZTogJ0tleWJvYXJkIFNob3J0Y3V0czonLFxuICBjaGVhdFNoZWV0SG90a2V5OiAnPycsXG4gIGNoZWF0U2hlZXRIb3RrZXlEZXNjcmlwdGlvbjogJ1Nob3cgLyBoaWRlIHRoaXMgaGVscCBtZW51JyxcbiAgY2hlYXRTaGVldENsb3NlRXNjOiBmYWxzZSxcbiAgY2hlYXRTaGVldENsb3NlRXNjRGVzY3JpcHRpb246ICdIaWRlIHRoaXMgaGVscCBtZW51J1xufTtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIE5neEhvdGtleXNTZXJ2aWNlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICBwcml2YXRlIF9zZXJ2aWNlT3B0aW9uczogSUhvdGtleU9wdGlvbnM7XG4gIHByaXZhdGUgX3JlZ2lzdGVyZWRIb3RrZXlzOiBTZXQ8SUhvdGtleT4gPSBuZXcgU2V0KCk7XG4gIHByaXZhdGUgX3BhdXNlZEhvdGtleXM6IFNldDxJSG90a2V5PiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBfbW91c2V0cmFwSW5zdGFuY2U6IE1vdXNldHJhcEluc3RhbmNlO1xuICBwcml2YXRlIF9jaGVhdFNoZWV0VG9nZ2xlZDogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3QoKTtcbiAgcHJpdmF0ZSBfcHJldmVudEluID0gWydJTlBVVCcsICdTRUxFQ1QnLCAnVEVYVEFSRUEnXTtcblxuICBjb25zdHJ1Y3RvcihASW5qZWN0KEhvdGtleU9wdGlvbnMpIHByaXZhdGUgX29wdGlvbnM6IElIb3RrZXlPcHRpb25zKSB7XG4gICAgdGhpcy5fc2VydmljZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKF9kZWZhdWx0T3B0aW9ucywgdGhpcy5fb3B0aW9ucyk7XG4gICAgTW91c2V0cmFwLnByb3RvdHlwZS5zdG9wQ2FsbGJhY2sgPSAoZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBjb21ibzogc3RyaW5nLCBjYWxsYmFjazogRnVuY3Rpb24pID0+IHtcbiAgICAgIC8vIGlmIHRoZSBlbGVtZW50IGhhcyB0aGUgY2xhc3MgXCJtb3VzZXRyYXBcIiB0aGVuIG5vIG5lZWQgdG8gc3RvcFxuICAgICAgaWYgKCgnICcgKyBlbGVtZW50LmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignIG1vdXNldHJhcCAnKSA+IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoZWxlbWVudC5jb250ZW50RWRpdGFibGUgJiYgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG4gICAgfTtcbiAgICB0aGlzLl9tb3VzZXRyYXBJbnN0YW5jZSA9IG5ldyAoPGFueT5Nb3VzZXRyYXApKCk7XG4gICAgaWYgKCF0aGlzLl9zZXJ2aWNlT3B0aW9ucy5kaXNhYmxlQ2hlYXRTaGVldCkge1xuICAgICAgdGhpcy5yZWdpc3Rlcih7XG4gICAgICAgIGNvbWJvOiB0aGlzLl9zZXJ2aWNlT3B0aW9ucy5jaGVhdFNoZWV0SG90a2V5LFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICB0aGlzLl9jaGVhdFNoZWV0VG9nZ2xlZC5uZXh0KCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuX3NlcnZpY2VPcHRpb25zLmNoZWF0U2hlZXRIb3RrZXlEZXNjcmlwdGlvblxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NlcnZpY2VPcHRpb25zLmNoZWF0U2hlZXRDbG9zZUVzYykge1xuICAgICAgdGhpcy5yZWdpc3Rlcih7XG4gICAgICAgIGNvbWJvOiAnZXNjJyxcbiAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgICAgdGhpcy5fY2hlYXRTaGVldFRvZ2dsZWQubmV4dChmYWxzZSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSxcbiAgICAgICAgYWxsb3dJbjogWydIT1RLRVlTLUNIRUFUU0hFRVQnXSxcbiAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuX3NlcnZpY2VPcHRpb25zLmNoZWF0U2hlZXRDbG9zZUVzY0Rlc2NyaXB0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVnaXN0ZXJlZCBob3RrZXlzIGFzIGFycmF5LlxuICAgKiBAcmV0dXJucyBhbGwgcmVnaXN0ZXJlZCBob3RrZXlzXG4gICAqL1xuICBwdWJsaWMgZ2V0IGhvdGtleXMoKTogSUhvdGtleVtdIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9yZWdpc3RlcmVkSG90a2V5cyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBPYnNlcnZhYmxlIHN0cmVhbSBpbmRpY2F0aW5nIHRoZSBjaGVhdHNoZWV0cyB2aXNpYmlsaXR5IHdhcyB0b2dnbGVkLlxuICAgKiBAcmV0dXJucyBzdHJlYW0gaW5kaWNhdGluZyB0aGUgY2hlYXRzaGVldHMgdmlzaWJpbGl0eSB3YXMgdG9nZ2xlZFxuICAgKi9cbiAgcHVibGljIGdldCBjaGVhdFNoZWV0VG9nZ2xlZCgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gdGhpcy5fY2hlYXRTaGVldFRvZ2dsZWQuYXNPYnNlcnZhYmxlKCkucGlwZShcbiAgICAgIHNoYXJlKClcbiAgICApO1xuICB9XG5cbiAgcHVibGljIGdldCBvcHRpb25zKCk6IElIb3RrZXlPcHRpb25zIHtcbiAgICByZXR1cm4gdGhpcy5fc2VydmljZU9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgbmV3IGhvdGtleS9uZXcgaG90a2V5cyB3aXRoIGl0J3MvdGhlaXIgaGFuZGxlcihzKS5cbiAgICogQHBhcmFtIGhvdGtleSBob3RrZXlzIHRvIGxpc3RlbiBmb3JcbiAgICogQHBhcmFtIHVucGF1c2luZyBmbGFnIGluZGljYXRpbmcgaWYgdGhlIGhvdGtleXMgc2hvdWxkIGJlIHVucGF1c2VkXG4gICAqL1xuICBwdWJsaWMgcmVnaXN0ZXIoaG90a2V5OiBJSG90a2V5IHwgSUhvdGtleVtdLCB1bnBhdXNpbmcgPSBmYWxzZSk6IHZvaWQge1xuICAgIGxldCBob3RrZXlzOiBJSG90a2V5W10gPSBbXS5jb25jYXQoaG90a2V5KTtcbiAgICBpZiAodW5wYXVzaW5nKSB7XG4gICAgICBob3RrZXlzID0gQXJyYXkuZnJvbSh0aGlzLl9wYXVzZWRIb3RrZXlzKTtcbiAgICB9XG4gICAgaG90a2V5cy5mb3JFYWNoKGggPT4ge1xuICAgICAgaWYgKHVucGF1c2luZykge1xuICAgICAgICB0aGlzLl9wYXVzZWRIb3RrZXlzLmRlbGV0ZShoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlZ2lzdGVyZWRIb3RrZXlzLmFkZChoKTtcbiAgICAgIHRoaXMuYmluZFRvTW91c3RyYXAoaCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhL3RoZSByZWdpc3RlcmVkIGhvdGtleShzKS5cbiAgICogQHBhcmFtIGhvdGtleSBob3RrZXkgZmlsdGVyXG4gICAqIEBwYXJhbSBwYXVzaW5nIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgaG90a2V5cyBzaG91bGQgYmUgcGF1c2VkXG4gICAqL1xuICBwdWJsaWMgdW5yZWdpc3Rlcihob3RrZXk6IElIb3RrZXkgfCBJSG90a2V5W10sIHBhdXNpbmcgPSBmYWxzZSk6IHZvaWQge1xuICAgIGNvbnN0IGhvdGtleXM6IElIb3RrZXlbXSA9IFtdLmNvbmNhdChob3RrZXkpO1xuXG4gICAgaG90a2V5cy5mb3JFYWNoKGggPT4ge1xuICAgICAgdGhpcy5fcmVnaXN0ZXJlZEhvdGtleXMuZGVsZXRlKGgpO1xuICAgICAgaWYgKHBhdXNpbmcpIHtcbiAgICAgICAgdGhpcy5fcGF1c2VkSG90a2V5cy5hZGQoaCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9tb3VzZXRyYXBJbnN0YW5jZS51bmJpbmQoaC5jb21ibywgaC5zcGVjaWZpY0V2ZW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFsbCBob3RrZXlzIG1hdGNoaW5nIHRoZSBwYXNzZWQgY29tYm8ocykuXG4gICAqIEBwYXJhbSBjb21ibyBjb21ibyB0byBtYXRjaCBhZ2FpbnN0XG4gICAqIEByZXR1cm5zIGFsbCBtYXRjaGVkIGhvdGtleXNcbiAgICovXG4gIHB1YmxpYyBnZXQoY29tYm8/OiBzdHJpbmcgfCBzdHJpbmdbXSk6IElIb3RrZXlbXSB7XG4gICAgcmV0dXJuIHRoaXMuaG90a2V5cy5maWx0ZXIoaCA9PiBoLmNvbWJvID09PSBjb21ibyk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgbGlzdGVuaW5nIGZvciB0aGUgc3BlY2lmaWVkIGhvdGtleXMuXG4gICAqIEBwYXJhbSBob3RrZXkgaG90a2V5IGZpbHRlclxuICAgKi9cbiAgcHVibGljIHBhdXNlKGhvdGtleT86IElIb3RrZXkgfCBJSG90a2V5W10pOiB2b2lkIHtcbiAgICBpZiAoIWhvdGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMucGF1c2UodGhpcy5ob3RrZXlzKTtcbiAgICB9XG4gICAgY29uc3QgaG90a2V5czogSUhvdGtleVtdID0gW10uY29uY2F0KGhvdGtleSk7XG4gICAgdGhpcy51bnJlZ2lzdGVyKGhvdGtleXMsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZXMgbGlzdGVuaW5nIGZvciB0aGUgc3BlY2lmaWVkIGhvdGtleXMuXG4gICAqIEBwYXJhbSBob3RrZXkgaG90a2V5IGZpbHRlclxuICAgKi9cbiAgcHVibGljIHVucGF1c2UoaG90a2V5PzogSUhvdGtleSB8IElIb3RrZXlbXSk6IHZvaWQge1xuICAgIGlmICghaG90a2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy51bnBhdXNlKHRoaXMuaG90a2V5cyk7XG4gICAgfVxuICAgIGNvbnN0IGhvdGtleXM6IElIb3RrZXlbXSA9IFtdLmNvbmNhdChob3RrZXkpO1xuICAgIHRoaXMucmVnaXN0ZXIoaG90a2V5cywgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIGFsbCBob3RrZXlzLlxuICAgKi9cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuX21vdXNldHJhcEluc3RhbmNlLnJlc2V0KCk7XG4gICAgdGhpcy5fcmVnaXN0ZXJlZEhvdGtleXMuY2xlYXIoKTtcbiAgICB0aGlzLl9wYXVzZWRIb3RrZXlzLmNsZWFyKCk7XG4gIH1cblxuICBwdWJsaWMgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgcHJpdmF0ZSBiaW5kVG9Nb3VzdHJhcChob3RrZXk6IElIb3RrZXkpOiB2b2lkIHtcblxuICAgIHRoaXMuX21vdXNldHJhcEluc3RhbmNlLmJpbmQoaG90a2V5LmNvbWJvLFxuICAgICAgKGV2ZW50OiBLZXlib2FyZEV2ZW50LCBjb21ibzogc3RyaW5nKSA9PiB7XG4gICAgICAgIGxldCBzaG91bGRFeGVjdXRlID0gdHJ1ZTtcblxuICAgICAgICAvLyBpZiB0aGUgY2FsbGJhY2sgaXMgZXhlY3V0ZWQgZGlyZWN0bHkgYGhvdGtleS5nZXQoJ3cnKS5jYWxsYmFjaygpYFxuICAgICAgICAvLyB0aGVyZSB3aWxsIGJlIG5vIGV2ZW50LCBzbyBqdXN0IGV4ZWN1dGUgdGhlIGNhbGxiYWNrLlxuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICBjb25zdCB0YXJnZXQ6IEhUTUxFbGVtZW50ID0gPEhUTUxFbGVtZW50PihldmVudC50YXJnZXQgfHwgZXZlbnQuc3JjRWxlbWVudCk7IC8vIHNyY0VsZW1lbnQgaXMgSUUgb25seVxuICAgICAgICAgIGNvbnN0IG5vZGVOYW1lOiBzdHJpbmcgPSB0YXJnZXQubm9kZU5hbWUudG9VcHBlckNhc2UoKTtcblxuICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBpbnB1dCBoYXMgYSBtb3VzZXRyYXAgY2xhc3MsIGFuZCBza2lwIGNoZWNraW5nIHByZXZlbnRJbiBpZiBzb1xuICAgICAgICAgIGlmICgoJyAnICsgdGFyZ2V0LmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignIG1vdXNldHJhcCAnKSA+IC0xKSB7XG4gICAgICAgICAgICBzaG91bGRFeGVjdXRlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3ByZXZlbnRJbi5pbmRleE9mKG5vZGVOYW1lKSA+IC0xICYmIGhvdGtleS5hbGxvd0luLm1hcChhbGxvdyA9PiBhbGxvdy50b1VwcGVyQ2FzZSgpKS5pbmRleE9mKG5vZGVOYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IGV4ZWN1dGUgY2FsbGJhY2sgaWYgdGhlIGV2ZW50IHdhcyBmaXJlZCBmcm9tIGluc2lkZSBhbiBlbGVtZW50IGxpc3RlZCBpbiBwcmV2ZW50SW4gYnV0IG5vdCBpbiBhbGxvd0luXG4gICAgICAgICAgICBzaG91bGRFeGVjdXRlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNob3VsZEV4ZWN1dGUpIHtcbiAgICAgICAgICByZXR1cm4gaG90a2V5LmhhbmRsZXIuYXBwbHkodGhpcywgW2V2ZW50LCBjb21ib10pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaG90a2V5LnNwZWNpZmljRXZlbnQpO1xuICB9XG59XG4iXX0=