(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('mousetrap'), require('rxjs/internal/operators'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('@balticcode/ngx-hotkeys', ['exports', '@angular/core', 'rxjs', 'mousetrap', 'rxjs/internal/operators', '@angular/common'], factory) :
    (factory((global.balticcode = global.balticcode || {}, global.balticcode['ngx-hotkeys'] = {}),global.ng.core,global.rxjs,null,global.rxjs['internal/operators'],global.ng.common));
}(this, (function (exports,core,rxjs,mousetrap,operators,common) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var HotkeyOptions = new core.InjectionToken('HotkeyOptions');

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var _defaultOptions = {
        disableCheatSheet: false,
        cheatSheetTitle: 'Keyboard Shortcuts:',
        cheatSheetHotkey: '?',
        cheatSheetHotkeyDescription: 'Show / hide this help menu',
        cheatSheetCloseEsc: false,
        cheatSheetCloseEscDescription: 'Hide this help menu'
    };
    var NgxHotkeysService = /** @class */ (function () {
        function NgxHotkeysService(_options) {
            this._options = _options;
            this._registeredHotkeys = new Set();
            this._pausedHotkeys = new Set();
            this._cheatSheetToggled = new rxjs.Subject();
            this._preventIn = ['INPUT', 'SELECT', 'TEXTAREA'];
            this._serviceOptions = Object.assign(_defaultOptions, this._options);
            Mousetrap.prototype.stopCallback = function (event, element, combo, callback) {
                // if the element has the class "mousetrap" then no need to stop
                if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
                    return false;
                }
                return (element.contentEditable && element.contentEditable === 'true');
            };
            this._mousetrapInstance = new ( /** @type {?} */(Mousetrap))();
            if (!this._serviceOptions.disableCheatSheet) {
                this.register({
                    combo: this._serviceOptions.cheatSheetHotkey,
                    handler: function (event) {
                        this._cheatSheetToggled.next();
                    }.bind(this),
                    description: this._serviceOptions.cheatSheetHotkeyDescription
                });
            }
            if (this._serviceOptions.cheatSheetCloseEsc) {
                this.register({
                    combo: 'esc',
                    handler: function (event) {
                        this._cheatSheetToggled.next(false);
                    }.bind(this),
                    allowIn: ['HOTKEYS-CHEATSHEET'],
                    description: this._serviceOptions.cheatSheetCloseEscDescription
                });
            }
        }
        Object.defineProperty(NgxHotkeysService.prototype, "hotkeys", {
            get: /**
             * Returns the registered hotkeys as array.
             * @return {?} all registered hotkeys
             */ function () {
                return Array.from(this._registeredHotkeys);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxHotkeysService.prototype, "cheatSheetToggled", {
            get: /**
             * Returns an Observable stream indicating the cheatsheets visibility was toggled.
             * @return {?} stream indicating the cheatsheets visibility was toggled
             */ function () {
                return this._cheatSheetToggled.asObservable().pipe(operators.share());
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NgxHotkeysService.prototype, "options", {
            get: /**
             * @return {?}
             */ function () {
                return this._serviceOptions;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Registers a new hotkey/new hotkeys with it's/their handler(s).
         * @param {?} hotkey hotkeys to listen for
         * @param {?=} unpausing flag indicating if the hotkeys should be unpaused
         * @return {?}
         */
        NgxHotkeysService.prototype.register = /**
         * Registers a new hotkey/new hotkeys with it's/their handler(s).
         * @param {?} hotkey hotkeys to listen for
         * @param {?=} unpausing flag indicating if the hotkeys should be unpaused
         * @return {?}
         */
            function (hotkey, unpausing) {
                var _this = this;
                if (unpausing === void 0) {
                    unpausing = false;
                }
                /** @type {?} */
                var hotkeys = [].concat(hotkey);
                if (unpausing) {
                    hotkeys = Array.from(this._pausedHotkeys);
                }
                hotkeys.forEach(function (h) {
                    if (unpausing) {
                        _this._pausedHotkeys.delete(h);
                    }
                    _this._registeredHotkeys.add(h);
                    _this.bindToMoustrap(h);
                });
            };
        /**
         * Removes a/the registered hotkey(s).
         * @param {?} hotkey hotkey filter
         * @param {?=} pausing flag indicating if the hotkeys should be paused
         * @return {?}
         */
        NgxHotkeysService.prototype.unregister = /**
         * Removes a/the registered hotkey(s).
         * @param {?} hotkey hotkey filter
         * @param {?=} pausing flag indicating if the hotkeys should be paused
         * @return {?}
         */
            function (hotkey, pausing) {
                var _this = this;
                if (pausing === void 0) {
                    pausing = false;
                }
                /** @type {?} */
                var hotkeys = [].concat(hotkey);
                hotkeys.forEach(function (h) {
                    _this._registeredHotkeys.delete(h);
                    if (pausing) {
                        _this._pausedHotkeys.add(h);
                    }
                    _this._mousetrapInstance.unbind(h.combo, h.specificEvent);
                });
            };
        /**
         * Returns all hotkeys matching the passed combo(s).
         * @param {?=} combo combo to match against
         * @return {?} all matched hotkeys
         */
        NgxHotkeysService.prototype.get = /**
         * Returns all hotkeys matching the passed combo(s).
         * @param {?=} combo combo to match against
         * @return {?} all matched hotkeys
         */
            function (combo) {
                return this.hotkeys.filter(function (h) { return h.combo === combo; });
            };
        /**
         * Stops listening for the specified hotkeys.
         * @param {?=} hotkey hotkey filter
         * @return {?}
         */
        NgxHotkeysService.prototype.pause = /**
         * Stops listening for the specified hotkeys.
         * @param {?=} hotkey hotkey filter
         * @return {?}
         */
            function (hotkey) {
                if (!hotkey) {
                    return this.pause(this.hotkeys);
                }
                /** @type {?} */
                var hotkeys = [].concat(hotkey);
                this.unregister(hotkeys, true);
            };
        /**
         * Resumes listening for the specified hotkeys.
         * @param {?=} hotkey hotkey filter
         * @return {?}
         */
        NgxHotkeysService.prototype.unpause = /**
         * Resumes listening for the specified hotkeys.
         * @param {?=} hotkey hotkey filter
         * @return {?}
         */
            function (hotkey) {
                if (!hotkey) {
                    return this.unpause(this.hotkeys);
                }
                /** @type {?} */
                var hotkeys = [].concat(hotkey);
                this.register(hotkeys, true);
            };
        /**
         * Resets all hotkeys.
         * @return {?}
         */
        NgxHotkeysService.prototype.reset = /**
         * Resets all hotkeys.
         * @return {?}
         */
            function () {
                this._mousetrapInstance.reset();
                this._registeredHotkeys.clear();
                this._pausedHotkeys.clear();
            };
        /**
         * @return {?}
         */
        NgxHotkeysService.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.reset();
            };
        /**
         * @param {?} hotkey
         * @return {?}
         */
        NgxHotkeysService.prototype.bindToMoustrap = /**
         * @param {?} hotkey
         * @return {?}
         */
            function (hotkey) {
                var _this = this;
                this._mousetrapInstance.bind(hotkey.combo, function (event, combo) {
                    /** @type {?} */
                    var shouldExecute = true;
                    // if the callback is executed directly `hotkey.get('w').callback()`
                    // there will be no event, so just execute the callback.
                    if (event) {
                        /** @type {?} */
                        var target = /** @type {?} */ ((event.target || event.srcElement));
                        /** @type {?} */
                        var nodeName = target.nodeName.toUpperCase();
                        // check if the input has a mousetrap class, and skip checking preventIn if so
                        if ((' ' + target.className + ' ').indexOf(' mousetrap ') > -1) {
                            shouldExecute = true;
                        }
                        else if (_this._preventIn.indexOf(nodeName) > -1 && hotkey.allowIn.map(function (allow) { return allow.toUpperCase(); }).indexOf(nodeName) === -1) {
                            // don't execute callback if the event was fired from inside an element listed in preventIn but not in allowIn
                            shouldExecute = false;
                        }
                    }
                    if (shouldExecute) {
                        return hotkey.handler.apply(_this, [event, combo]);
                    }
                }, hotkey.specificEvent);
            };
        NgxHotkeysService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        NgxHotkeysService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: [HotkeyOptions,] }] }
            ];
        };
        return NgxHotkeysService;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m)
            return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length)
                    o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var NgxHotkeysDirective = /** @class */ (function () {
        function NgxHotkeysDirective(_hotkeysService, _elementRef) {
            this._hotkeysService = _hotkeysService;
            this._elementRef = _elementRef;
            this._hotkeysList = [];
            this._oldHotkeys = [];
            this._mousetrapInstance = new Mousetrap(this._elementRef.nativeElement); // Bind hotkeys to the current element (and any children)
        }
        /**
         * @return {?}
         */
        NgxHotkeysDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var e_1, _a;
                try {
                    for (var _b = __values(this.hotkeys), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var hotkey = _c.value;
                        /** @type {?} */
                        var combo = Object.keys(hotkey)[0];
                        /** @type {?} */
                        var hotkeyObj = {
                            combo: combo,
                            handler: hotkey[combo]
                        };
                        /** @type {?} */
                        var filtered = this._hotkeysService.get(combo);
                        /** @type {?} */
                        var oldHotkey = !!filtered && !!filtered.length ? filtered[0] : null;
                        if (oldHotkey !== null) { // We let the user overwrite callbacks temporarily if you specify it in HTML
                            // We let the user overwrite callbacks temporarily if you specify it in HTML
                            this._oldHotkeys.push(oldHotkey);
                            this._hotkeysService.unregister(oldHotkey);
                        }
                        this._hotkeysList.push(hotkeyObj);
                        this._mousetrapInstance.bind(hotkeyObj.combo, hotkeyObj.handler);
                    }
                }
                catch (e_1_1) {
                    e_1 = { error: e_1_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_1)
                            throw e_1.error;
                    }
                }
            };
        /**
         * @return {?}
         */
        NgxHotkeysDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                var e_2, _a;
                try {
                    for (var _b = __values(this._hotkeysList), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var hotkey = _c.value;
                        this._mousetrapInstance.unbind(hotkey.combo);
                    }
                }
                catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return))
                            _a.call(_b);
                    }
                    finally {
                        if (e_2)
                            throw e_2.error;
                    }
                }
                this._hotkeysService.register(this._oldHotkeys);
            };
        NgxHotkeysDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[ngxHotkeys]',
                        providers: [NgxHotkeysService]
                    },] }
        ];
        /** @nocollapse */
        NgxHotkeysDirective.ctorParameters = function () {
            return [
                { type: NgxHotkeysService },
                { type: core.ElementRef }
            ];
        };
        NgxHotkeysDirective.propDecorators = {
            hotkeys: [{ type: core.Input }]
        };
        return NgxHotkeysDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var NgxCheatsheetComponent = /** @class */ (function () {
        function NgxCheatsheetComponent(hotkeysService) {
            this.hotkeysService = hotkeysService;
            this.helpVisible = false;
            this._map = {
                command: '\u2318',
                // ⌘
                shift: '\u21E7',
                // ⇧
                left: '\u2190',
                // ←
                right: '\u2192',
                // →
                up: '\u2191',
                // ↑
                down: '\u2193',
                // ↓
                'return': '\u23CE',
                // ⏎
                backspace: '\u232B' // ⌫
            };
            this.title = this.hotkeysService.options.cheatSheetTitle;
        }
        /**
         * @return {?}
         */
        NgxCheatsheetComponent.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                var _this = this;
                this._subscription = this.hotkeysService.cheatSheetToggled
                    .subscribe(function (isOpen) {
                    if (isOpen !== false) {
                        _this.hotkeys = _this.hotkeysService.hotkeys
                            .filter(function (hotkey) { return hotkey.description; });
                    }
                    if (isOpen === false) {
                        _this.helpVisible = false;
                    }
                    else {
                        _this.toggleCheatSheet();
                    }
                });
            };
        /**
         * @param {?} hotkey
         * @return {?}
         */
        NgxCheatsheetComponent.prototype.formatHotkey = /**
         * @param {?} hotkey
         * @return {?}
         */
            function (hotkey) {
                if (!hotkey.format) {
                    /** @type {?} */
                    var combo = Array.isArray(hotkey.combo) ? hotkey.combo[0] : hotkey.combo;
                    /** @type {?} */
                    var sequence = combo.split(/[\s]/);
                    for (var i = 0; i < sequence.length; i++) {
                        sequence[i] = this.symbolize(sequence[i]);
                    }
                    hotkey.format = sequence;
                }
                return hotkey.format;
            };
        /**
         * @param {?} combo
         * @return {?}
         */
        NgxCheatsheetComponent.prototype.symbolize = /**
         * @param {?} combo
         * @return {?}
         */
            function (combo) {
                /** @type {?} */
                var comboSplit = combo.split('+');
                for (var i = 0; i < comboSplit.length; i++) {
                    // try to resolve command / ctrl based on OS:
                    if (comboSplit[i] === 'mod') {
                        if (window.navigator && window.navigator.platform.indexOf('Mac') >= 0) {
                            comboSplit[i] = 'command';
                        }
                        else {
                            comboSplit[i] = 'ctrl';
                        }
                    }
                    comboSplit[i] = this._map[comboSplit[i]] || comboSplit[i];
                }
                return comboSplit.join(' + ');
            };
        /**
         * @return {?}
         */
        NgxCheatsheetComponent.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                if (this._subscription) {
                    this._subscription.unsubscribe();
                }
            };
        /**
         * @return {?}
         */
        NgxCheatsheetComponent.prototype.toggleCheatSheet = /**
         * @return {?}
         */
            function () {
                this.helpVisible = !this.helpVisible;
            };
        NgxCheatsheetComponent.decorators = [
            { type: core.Component, args: [{
                        selector: 'ngx-cheatsheet',
                        template: "<div class=\"ngx-cheatsheet fade\" [ngClass]=\"{'in': helpVisible}\" style=\"display:none\">\n  <div class=\"ngx-cheatsheet__hotkeys\">\n    <h4 class=\"ngx-cheatsheet__hotkeys__title\">{{ title }}</h4>\n    <table>\n      <tbody>\n      <tr *ngFor=\"let hotkey of hotkeys\">\n        <td class=\"ngx-cheatsheet__hotkeys__keys\">\n          <span class=\"ngx-cheatsheet__hotkeys__keys__key\">{{ formatHotkey(hotkey) }}</span>\n        </td>\n        <td class=\"ngx-cheatsheet__hotkeys__keys__text\">{{ hotkey.description }}</td>\n      </tr>\n      </tbody>\n    </table>\n    <div class=\"ngx-cheatsheet__hotkeys__close\" (click)=\"toggleCheatSheet()\">&#215;</div>\n  </div>\n</div>\n",
                        styles: [".ngx-cheatsheet{display:table!important;position:fixed;width:100%;height:100%;top:0;left:0;color:#333;font-size:1em;background-color:rgba(255,255,255,.9)}.ngx-cheatsheet.fade{z-index:-1024;visibility:hidden;opacity:0;transition:opacity .15s linear}.ngx-cheatsheet.fade.in{z-index:10002;visibility:visible;opacity:1}.ngx-cheatsheet__hotkeys{width:100%;height:100%;display:table-cell;vertical-align:middle}.ngx-cheatsheet__hotkeys__title{font-weight:700;text-align:center;font-size:1.2em}.ngx-cheatsheet__hotkeys table{margin:auto;color:#333}.ngx-cheatsheet__hotkeys__keys{padding:5px;text-align:right}.ngx-cheatsheet__hotkeys__keys__key{display:inline-block;color:#fff;background-color:#333;border:1px solid #333;border-radius:5px;text-align:center;margin-right:5px;box-shadow:inset 0 1px 0 #666,0 1px 0 #bbb;padding:5px 9px;font-size:1em}.ngx-cheatsheet__hotkeys__keys__text{padding-left:10px;font-size:1em}.ngx-cheatsheet__hotkeys__close{position:fixed;top:20px;right:20px;font-size:2em;font-weight:700;padding:5px 10px;border:1px solid #ddd;border-radius:5px;min-height:45px;min-width:45px;text-align:center}@media all and (max-width:500px){.ngx-cheatsheet__hotkeys{font-size:.8em}}@media all and (min-width:750px){.ngx-cheatsheet__hotkeys{font-size:1.2em}}"]
                    }] }
        ];
        /** @nocollapse */
        NgxCheatsheetComponent.ctorParameters = function () {
            return [
                { type: NgxHotkeysService }
            ];
        };
        NgxCheatsheetComponent.propDecorators = {
            title: [{ type: core.Input }]
        };
        return NgxCheatsheetComponent;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var NgxHotkeysModule = /** @class */ (function () {
        function NgxHotkeysModule() {
        }
        /**
         * @param {?=} options
         * @return {?}
         */
        NgxHotkeysModule.forRoot = /**
         * @param {?=} options
         * @return {?}
         */
            function (options) {
                return {
                    ngModule: NgxHotkeysModule,
                    providers: [
                        NgxHotkeysService,
                        { provide: HotkeyOptions, useValue: options }
                    ]
                };
            };
        NgxHotkeysModule.decorators = [
            { type: core.NgModule, args: [{
                        imports: [common.CommonModule],
                        declarations: [NgxCheatsheetComponent, NgxHotkeysDirective],
                        exports: [NgxHotkeysDirective, NgxCheatsheetComponent],
                        providers: [NgxHotkeysService]
                    },] }
        ];
        return NgxHotkeysModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.NgxHotkeysService = NgxHotkeysService;
    exports.NgxHotkeysDirective = NgxHotkeysDirective;
    exports.NgxCheatsheetComponent = NgxCheatsheetComponent;
    exports.NgxHotkeysModule = NgxHotkeysModule;
    exports.ɵa = HotkeyOptions;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFsdGljY29kZS1uZ3gtaG90a2V5cy51bWQuanMubWFwIiwic291cmNlcyI6WyJuZzovL0BiYWx0aWNjb2RlL25neC1ob3RrZXlzL2xpYi90b2tlbi50cyIsIm5nOi8vQGJhbHRpY2NvZGUvbmd4LWhvdGtleXMvbGliL25neC1ob3RrZXlzLnNlcnZpY2UudHMiLCJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIiwibmc6Ly9AYmFsdGljY29kZS9uZ3gtaG90a2V5cy9saWIvbmd4LWhvdGtleXMuZGlyZWN0aXZlLnRzIiwibmc6Ly9AYmFsdGljY29kZS9uZ3gtaG90a2V5cy9saWIvbmd4LWNoZWF0c2hlZXQvbmd4LWNoZWF0c2hlZXQuY29tcG9uZW50LnRzIiwibmc6Ly9AYmFsdGljY29kZS9uZ3gtaG90a2V5cy9saWIvbmd4LWhvdGtleXMubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW5qZWN0aW9uVG9rZW59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHtJSG90a2V5T3B0aW9uc30gZnJvbSAnLi9pbnRlcmZhY2VzJztcclxuXHJcbmV4cG9ydCBjb25zdCBIb3RrZXlPcHRpb25zID0gbmV3IEluamVjdGlvblRva2VuPElIb3RrZXlPcHRpb25zPignSG90a2V5T3B0aW9ucycpO1xyXG4iLCJpbXBvcnQge0luamVjdCwgSW5qZWN0YWJsZSwgT25EZXN0cm95fSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7T2JzZXJ2YWJsZSwgU3ViamVjdH0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCAnbW91c2V0cmFwJztcblxuaW1wb3J0IHtJSG90a2V5LCBJSG90a2V5T3B0aW9uc30gZnJvbSAnLi9pbnRlcmZhY2VzJztcbmltcG9ydCB7SG90a2V5T3B0aW9uc30gZnJvbSAnLi90b2tlbic7XG5pbXBvcnQge3NoYXJlfSBmcm9tICdyeGpzL2ludGVybmFsL29wZXJhdG9ycyc7XG5cbmNvbnN0IF9kZWZhdWx0T3B0aW9uczogSUhvdGtleU9wdGlvbnMgPSB7XG4gIGRpc2FibGVDaGVhdFNoZWV0OiBmYWxzZSxcbiAgY2hlYXRTaGVldFRpdGxlOiAnS2V5Ym9hcmQgU2hvcnRjdXRzOicsXG4gIGNoZWF0U2hlZXRIb3RrZXk6ICc/JyxcbiAgY2hlYXRTaGVldEhvdGtleURlc2NyaXB0aW9uOiAnU2hvdyAvIGhpZGUgdGhpcyBoZWxwIG1lbnUnLFxuICBjaGVhdFNoZWV0Q2xvc2VFc2M6IGZhbHNlLFxuICBjaGVhdFNoZWV0Q2xvc2VFc2NEZXNjcmlwdGlvbjogJ0hpZGUgdGhpcyBoZWxwIG1lbnUnXG59O1xuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgTmd4SG90a2V5c1NlcnZpY2UgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuXG4gIHByaXZhdGUgX3NlcnZpY2VPcHRpb25zOiBJSG90a2V5T3B0aW9ucztcbiAgcHJpdmF0ZSBfcmVnaXN0ZXJlZEhvdGtleXM6IFNldDxJSG90a2V5PiA9IG5ldyBTZXQoKTtcbiAgcHJpdmF0ZSBfcGF1c2VkSG90a2V5czogU2V0PElIb3RrZXk+ID0gbmV3IFNldCgpO1xuICBwcml2YXRlIF9tb3VzZXRyYXBJbnN0YW5jZTogTW91c2V0cmFwSW5zdGFuY2U7XG4gIHByaXZhdGUgX2NoZWF0U2hlZXRUb2dnbGVkOiBTdWJqZWN0PGFueT4gPSBuZXcgU3ViamVjdCgpO1xuICBwcml2YXRlIF9wcmV2ZW50SW4gPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdURVhUQVJFQSddO1xuXG4gIGNvbnN0cnVjdG9yKEBJbmplY3QoSG90a2V5T3B0aW9ucykgcHJpdmF0ZSBfb3B0aW9uczogSUhvdGtleU9wdGlvbnMpIHtcbiAgICB0aGlzLl9zZXJ2aWNlT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oX2RlZmF1bHRPcHRpb25zLCB0aGlzLl9vcHRpb25zKTtcbiAgICBNb3VzZXRyYXAucHJvdG90eXBlLnN0b3BDYWxsYmFjayA9IChldmVudDogS2V5Ym9hcmRFdmVudCwgZWxlbWVudDogSFRNTEVsZW1lbnQsIGNvbWJvOiBzdHJpbmcsIGNhbGxiYWNrOiBGdW5jdGlvbikgPT4ge1xuICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgaGFzIHRoZSBjbGFzcyBcIm1vdXNldHJhcFwiIHRoZW4gbm8gbmVlZCB0byBzdG9wXG4gICAgICBpZiAoKCcgJyArIGVsZW1lbnQuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgbW91c2V0cmFwICcpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSAmJiBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbiAgICB9O1xuICAgIHRoaXMuX21vdXNldHJhcEluc3RhbmNlID0gbmV3ICg8YW55Pk1vdXNldHJhcCkoKTtcbiAgICBpZiAoIXRoaXMuX3NlcnZpY2VPcHRpb25zLmRpc2FibGVDaGVhdFNoZWV0KSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyKHtcbiAgICAgICAgY29tYm86IHRoaXMuX3NlcnZpY2VPcHRpb25zLmNoZWF0U2hlZXRIb3RrZXksXG4gICAgICAgIGhhbmRsZXI6IGZ1bmN0aW9uIChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICAgIHRoaXMuX2NoZWF0U2hlZXRUb2dnbGVkLm5leHQoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5fc2VydmljZU9wdGlvbnMuY2hlYXRTaGVldEhvdGtleURlc2NyaXB0aW9uXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc2VydmljZU9wdGlvbnMuY2hlYXRTaGVldENsb3NlRXNjKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyKHtcbiAgICAgICAgY29tYm86ICdlc2MnLFxuICAgICAgICBoYW5kbGVyOiBmdW5jdGlvbiAoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgICB0aGlzLl9jaGVhdFNoZWV0VG9nZ2xlZC5uZXh0KGZhbHNlKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpLFxuICAgICAgICBhbGxvd0luOiBbJ0hPVEtFWVMtQ0hFQVRTSEVFVCddLFxuICAgICAgICBkZXNjcmlwdGlvbjogdGhpcy5fc2VydmljZU9wdGlvbnMuY2hlYXRTaGVldENsb3NlRXNjRGVzY3JpcHRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZWdpc3RlcmVkIGhvdGtleXMgYXMgYXJyYXkuXG4gICAqIEByZXR1cm5zIGFsbCByZWdpc3RlcmVkIGhvdGtleXNcbiAgICovXG4gIHB1YmxpYyBnZXQgaG90a2V5cygpOiBJSG90a2V5W10ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX3JlZ2lzdGVyZWRIb3RrZXlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIE9ic2VydmFibGUgc3RyZWFtIGluZGljYXRpbmcgdGhlIGNoZWF0c2hlZXRzIHZpc2liaWxpdHkgd2FzIHRvZ2dsZWQuXG4gICAqIEByZXR1cm5zIHN0cmVhbSBpbmRpY2F0aW5nIHRoZSBjaGVhdHNoZWV0cyB2aXNpYmlsaXR5IHdhcyB0b2dnbGVkXG4gICAqL1xuICBwdWJsaWMgZ2V0IGNoZWF0U2hlZXRUb2dnbGVkKCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLl9jaGVhdFNoZWV0VG9nZ2xlZC5hc09ic2VydmFibGUoKS5waXBlKFxuICAgICAgc2hhcmUoKVxuICAgICk7XG4gIH1cblxuICBwdWJsaWMgZ2V0IG9wdGlvbnMoKTogSUhvdGtleU9wdGlvbnMge1xuICAgIHJldHVybiB0aGlzLl9zZXJ2aWNlT3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYSBuZXcgaG90a2V5L25ldyBob3RrZXlzIHdpdGggaXQncy90aGVpciBoYW5kbGVyKHMpLlxuICAgKiBAcGFyYW0gaG90a2V5IGhvdGtleXMgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0gdW5wYXVzaW5nIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgaG90a2V5cyBzaG91bGQgYmUgdW5wYXVzZWRcbiAgICovXG4gIHB1YmxpYyByZWdpc3Rlcihob3RrZXk6IElIb3RrZXkgfCBJSG90a2V5W10sIHVucGF1c2luZyA9IGZhbHNlKTogdm9pZCB7XG4gICAgbGV0IGhvdGtleXM6IElIb3RrZXlbXSA9IFtdLmNvbmNhdChob3RrZXkpO1xuICAgIGlmICh1bnBhdXNpbmcpIHtcbiAgICAgIGhvdGtleXMgPSBBcnJheS5mcm9tKHRoaXMuX3BhdXNlZEhvdGtleXMpO1xuICAgIH1cbiAgICBob3RrZXlzLmZvckVhY2goaCA9PiB7XG4gICAgICBpZiAodW5wYXVzaW5nKSB7XG4gICAgICAgIHRoaXMuX3BhdXNlZEhvdGtleXMuZGVsZXRlKGgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcmVnaXN0ZXJlZEhvdGtleXMuYWRkKGgpO1xuICAgICAgdGhpcy5iaW5kVG9Nb3VzdHJhcChoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEvdGhlIHJlZ2lzdGVyZWQgaG90a2V5KHMpLlxuICAgKiBAcGFyYW0gaG90a2V5IGhvdGtleSBmaWx0ZXJcbiAgICogQHBhcmFtIHBhdXNpbmcgZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBob3RrZXlzIHNob3VsZCBiZSBwYXVzZWRcbiAgICovXG4gIHB1YmxpYyB1bnJlZ2lzdGVyKGhvdGtleTogSUhvdGtleSB8IElIb3RrZXlbXSwgcGF1c2luZyA9IGZhbHNlKTogdm9pZCB7XG4gICAgY29uc3QgaG90a2V5czogSUhvdGtleVtdID0gW10uY29uY2F0KGhvdGtleSk7XG5cbiAgICBob3RrZXlzLmZvckVhY2goaCA9PiB7XG4gICAgICB0aGlzLl9yZWdpc3RlcmVkSG90a2V5cy5kZWxldGUoaCk7XG4gICAgICBpZiAocGF1c2luZykge1xuICAgICAgICB0aGlzLl9wYXVzZWRIb3RrZXlzLmFkZChoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21vdXNldHJhcEluc3RhbmNlLnVuYmluZChoLmNvbWJvLCBoLnNwZWNpZmljRXZlbnQpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGhvdGtleXMgbWF0Y2hpbmcgdGhlIHBhc3NlZCBjb21ibyhzKS5cbiAgICogQHBhcmFtIGNvbWJvIGNvbWJvIHRvIG1hdGNoIGFnYWluc3RcbiAgICogQHJldHVybnMgYWxsIG1hdGNoZWQgaG90a2V5c1xuICAgKi9cbiAgcHVibGljIGdldChjb21ibz86IHN0cmluZyB8IHN0cmluZ1tdKTogSUhvdGtleVtdIHtcbiAgICByZXR1cm4gdGhpcy5ob3RrZXlzLmZpbHRlcihoID0+IGguY29tYm8gPT09IGNvbWJvKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBsaXN0ZW5pbmcgZm9yIHRoZSBzcGVjaWZpZWQgaG90a2V5cy5cbiAgICogQHBhcmFtIGhvdGtleSBob3RrZXkgZmlsdGVyXG4gICAqL1xuICBwdWJsaWMgcGF1c2UoaG90a2V5PzogSUhvdGtleSB8IElIb3RrZXlbXSk6IHZvaWQge1xuICAgIGlmICghaG90a2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXVzZSh0aGlzLmhvdGtleXMpO1xuICAgIH1cbiAgICBjb25zdCBob3RrZXlzOiBJSG90a2V5W10gPSBbXS5jb25jYXQoaG90a2V5KTtcbiAgICB0aGlzLnVucmVnaXN0ZXIoaG90a2V5cywgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzdW1lcyBsaXN0ZW5pbmcgZm9yIHRoZSBzcGVjaWZpZWQgaG90a2V5cy5cbiAgICogQHBhcmFtIGhvdGtleSBob3RrZXkgZmlsdGVyXG4gICAqL1xuICBwdWJsaWMgdW5wYXVzZShob3RrZXk/OiBJSG90a2V5IHwgSUhvdGtleVtdKTogdm9pZCB7XG4gICAgaWYgKCFob3RrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnVucGF1c2UodGhpcy5ob3RrZXlzKTtcbiAgICB9XG4gICAgY29uc3QgaG90a2V5czogSUhvdGtleVtdID0gW10uY29uY2F0KGhvdGtleSk7XG4gICAgdGhpcy5yZWdpc3Rlcihob3RrZXlzLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgYWxsIGhvdGtleXMuXG4gICAqL1xuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5fbW91c2V0cmFwSW5zdGFuY2UucmVzZXQoKTtcbiAgICB0aGlzLl9yZWdpc3RlcmVkSG90a2V5cy5jbGVhcigpO1xuICAgIHRoaXMuX3BhdXNlZEhvdGtleXMuY2xlYXIoKTtcbiAgfVxuXG4gIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICBwcml2YXRlIGJpbmRUb01vdXN0cmFwKGhvdGtleTogSUhvdGtleSk6IHZvaWQge1xuXG4gICAgdGhpcy5fbW91c2V0cmFwSW5zdGFuY2UuYmluZChob3RrZXkuY29tYm8sXG4gICAgICAoZXZlbnQ6IEtleWJvYXJkRXZlbnQsIGNvbWJvOiBzdHJpbmcpID0+IHtcbiAgICAgICAgbGV0IHNob3VsZEV4ZWN1dGUgPSB0cnVlO1xuXG4gICAgICAgIC8vIGlmIHRoZSBjYWxsYmFjayBpcyBleGVjdXRlZCBkaXJlY3RseSBgaG90a2V5LmdldCgndycpLmNhbGxiYWNrKClgXG4gICAgICAgIC8vIHRoZXJlIHdpbGwgYmUgbm8gZXZlbnQsIHNvIGp1c3QgZXhlY3V0ZSB0aGUgY2FsbGJhY2suXG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgIGNvbnN0IHRhcmdldDogSFRNTEVsZW1lbnQgPSA8SFRNTEVsZW1lbnQ+KGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50KTsgLy8gc3JjRWxlbWVudCBpcyBJRSBvbmx5XG4gICAgICAgICAgY29uc3Qgbm9kZU5hbWU6IHN0cmluZyA9IHRhcmdldC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGlucHV0IGhhcyBhIG1vdXNldHJhcCBjbGFzcywgYW5kIHNraXAgY2hlY2tpbmcgcHJldmVudEluIGlmIHNvXG4gICAgICAgICAgaWYgKCgnICcgKyB0YXJnZXQuY2xhc3NOYW1lICsgJyAnKS5pbmRleE9mKCcgbW91c2V0cmFwICcpID4gLTEpIHtcbiAgICAgICAgICAgIHNob3VsZEV4ZWN1dGUgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fcHJldmVudEluLmluZGV4T2Yobm9kZU5hbWUpID4gLTEgJiYgaG90a2V5LmFsbG93SW4ubWFwKGFsbG93ID0+IGFsbG93LnRvVXBwZXJDYXNlKCkpLmluZGV4T2Yobm9kZU5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgLy8gZG9uJ3QgZXhlY3V0ZSBjYWxsYmFjayBpZiB0aGUgZXZlbnQgd2FzIGZpcmVkIGZyb20gaW5zaWRlIGFuIGVsZW1lbnQgbGlzdGVkIGluIHByZXZlbnRJbiBidXQgbm90IGluIGFsbG93SW5cbiAgICAgICAgICAgIHNob3VsZEV4ZWN1dGUgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkRXhlY3V0ZSkge1xuICAgICAgICAgIHJldHVybiBob3RrZXkuaGFuZGxlci5hcHBseSh0aGlzLCBbZXZlbnQsIGNvbWJvXSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBob3RrZXkuc3BlY2lmaWNFdmVudCk7XG4gIH1cbn1cbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAob1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG4iLCJpbXBvcnQge0RpcmVjdGl2ZSwgRWxlbWVudFJlZiwgSW5wdXQsIE9uRGVzdHJveSwgT25Jbml0fSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuXHJcbmltcG9ydCAnbW91c2V0cmFwJztcclxuXHJcbmltcG9ydCB7SG90S2V5TWFwLCBJSG90a2V5fSBmcm9tICcuL2ludGVyZmFjZXMnO1xyXG5pbXBvcnQge05neEhvdGtleXNTZXJ2aWNlfSBmcm9tICcuL25neC1ob3RrZXlzLnNlcnZpY2UnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdbbmd4SG90a2V5c10nLFxyXG4gIHByb3ZpZGVyczogW05neEhvdGtleXNTZXJ2aWNlXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTmd4SG90a2V5c0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcclxuXHJcbiAgQElucHV0KClcclxuICBob3RrZXlzOiBIb3RLZXlNYXBbXTtcclxuXHJcbiAgcHJpdmF0ZSBfbW91c2V0cmFwSW5zdGFuY2U6IE1vdXNldHJhcEluc3RhbmNlO1xyXG4gIHByaXZhdGUgX2hvdGtleXNMaXN0OiBJSG90a2V5W10gPSBbXTtcclxuICBwcml2YXRlIF9vbGRIb3RrZXlzOiBJSG90a2V5W10gPSBbXTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBfaG90a2V5c1NlcnZpY2U6IE5neEhvdGtleXNTZXJ2aWNlLCBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmKSB7XHJcbiAgICB0aGlzLl9tb3VzZXRyYXBJbnN0YW5jZSA9IG5ldyBNb3VzZXRyYXAodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTsgLy8gQmluZCBob3RrZXlzIHRvIHRoZSBjdXJyZW50IGVsZW1lbnQgKGFuZCBhbnkgY2hpbGRyZW4pXHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIGZvciAoY29uc3QgaG90a2V5IG9mIHRoaXMuaG90a2V5cykge1xyXG4gICAgICBjb25zdCBjb21ibyA9IE9iamVjdC5rZXlzKGhvdGtleSlbMF07XHJcbiAgICAgIGNvbnN0IGhvdGtleU9iajogSUhvdGtleSA9IHtcclxuICAgICAgICBjb21ibzogY29tYm8sXHJcbiAgICAgICAgaGFuZGxlcjogaG90a2V5W2NvbWJvXVxyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBmaWx0ZXJlZDogSUhvdGtleVtdID0gdGhpcy5faG90a2V5c1NlcnZpY2UuZ2V0KGNvbWJvKTtcclxuICAgICAgY29uc3Qgb2xkSG90a2V5OiBJSG90a2V5ID0gISFmaWx0ZXJlZCAmJiAhIWZpbHRlcmVkLmxlbmd0aCA/IGZpbHRlcmVkWzBdIDogbnVsbDtcclxuICAgICAgaWYgKG9sZEhvdGtleSAhPT0gbnVsbCkgeyAvLyBXZSBsZXQgdGhlIHVzZXIgb3ZlcndyaXRlIGNhbGxiYWNrcyB0ZW1wb3JhcmlseSBpZiB5b3Ugc3BlY2lmeSBpdCBpbiBIVE1MXHJcbiAgICAgICAgdGhpcy5fb2xkSG90a2V5cy5wdXNoKG9sZEhvdGtleSk7XHJcbiAgICAgICAgdGhpcy5faG90a2V5c1NlcnZpY2UudW5yZWdpc3RlcihvbGRIb3RrZXkpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2hvdGtleXNMaXN0LnB1c2goaG90a2V5T2JqKTtcclxuICAgICAgdGhpcy5fbW91c2V0cmFwSW5zdGFuY2UuYmluZChob3RrZXlPYmouY29tYm8sIGhvdGtleU9iai5oYW5kbGVyKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgZm9yIChjb25zdCBob3RrZXkgb2YgdGhpcy5faG90a2V5c0xpc3QpIHtcclxuICAgICAgdGhpcy5fbW91c2V0cmFwSW5zdGFuY2UudW5iaW5kKGhvdGtleS5jb21ibyk7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9ob3RrZXlzU2VydmljZS5yZWdpc3Rlcih0aGlzLl9vbGRIb3RrZXlzKTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHtDb21wb25lbnQsIElucHV0LCBPbkRlc3Ryb3ksIE9uSW5pdH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1N1YnNjcmlwdGlvbn0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7Tmd4SG90a2V5c1NlcnZpY2V9IGZyb20gJy4uL25neC1ob3RrZXlzLnNlcnZpY2UnO1xuaW1wb3J0IHtJSG90a2V5fSBmcm9tICcuLi9pbnRlcmZhY2VzJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbmd4LWNoZWF0c2hlZXQnLFxuICB0ZW1wbGF0ZVVybDogJy4vbmd4LWNoZWF0c2hlZXQuY29tcG9uZW50Lmh0bWwnLFxuICBzdHlsZVVybHM6IFsnLi9uZ3gtY2hlYXRzaGVldC5jb21wb25lbnQuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIE5neENoZWF0c2hlZXRDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgQElucHV0KClcbiAgdGl0bGU6IHN0cmluZztcblxuICBoZWxwVmlzaWJsZSA9IGZhbHNlO1xuICBob3RrZXlzOiBJSG90a2V5W107XG5cbiAgcHJpdmF0ZSBfc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG5cbiAgcHJpdmF0ZSBfbWFwOiBhbnkgPSB7XG4gICAgY29tbWFuZDogJ1xcdTIzMTgnLCAgICAgICAvLyDDosKMwphcbiAgICBzaGlmdDogJ1xcdTIxRTcnLCAgICAgICAgIC8vIMOiwofCp1xuICAgIGxlZnQ6ICdcXHUyMTkwJywgICAgICAgICAgLy8gw6LChsKQXG4gICAgcmlnaHQ6ICdcXHUyMTkyJywgICAgICAgICAvLyDDosKGwpJcbiAgICB1cDogJ1xcdTIxOTEnLCAgICAgICAgICAgIC8vIMOiwobCkVxuICAgIGRvd246ICdcXHUyMTkzJywgICAgICAgICAgLy8gw6LChsKTXG4gICAgJ3JldHVybic6ICdcXHUyM0NFJywgICAgICAvLyDDosKPwo5cbiAgICBiYWNrc3BhY2U6ICdcXHUyMzJCJyAgICAgIC8vIMOiwozCq1xuICB9O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaG90a2V5c1NlcnZpY2U6IE5neEhvdGtleXNTZXJ2aWNlKSB7XG4gICAgdGhpcy50aXRsZSA9IHRoaXMuaG90a2V5c1NlcnZpY2Uub3B0aW9ucy5jaGVhdFNoZWV0VGl0bGU7XG4gIH1cblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24gPSB0aGlzLmhvdGtleXNTZXJ2aWNlLmNoZWF0U2hlZXRUb2dnbGVkXG4gICAgICAuc3Vic2NyaWJlKChpc09wZW4pID0+IHtcbiAgICAgICAgaWYgKGlzT3BlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLmhvdGtleXMgPSB0aGlzLmhvdGtleXNTZXJ2aWNlLmhvdGtleXNcbiAgICAgICAgICAgIC5maWx0ZXIoaG90a2V5ID0+IGhvdGtleS5kZXNjcmlwdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNPcGVuID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuaGVscFZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRvZ2dsZUNoZWF0U2hlZXQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICBmb3JtYXRIb3RrZXkoaG90a2V5OiBJSG90a2V5KTogc3RyaW5nW10ge1xuICAgIGlmICghaG90a2V5LmZvcm1hdCkge1xuICAgICAgY29uc3QgY29tYm86IHN0cmluZyA9IEFycmF5LmlzQXJyYXkoaG90a2V5LmNvbWJvKSA/IGhvdGtleS5jb21ib1swXSA6IGhvdGtleS5jb21ibztcbiAgICAgIGNvbnN0IHNlcXVlbmNlOiBzdHJpbmdbXSA9IGNvbWJvLnNwbGl0KC9bXFxzXS8pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZXF1ZW5jZVtpXSA9IHRoaXMuc3ltYm9saXplKHNlcXVlbmNlW2ldKTtcbiAgICAgIH1cbiAgICAgIGhvdGtleS5mb3JtYXQgPSBzZXF1ZW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIGhvdGtleS5mb3JtYXQ7XG4gIH1cblxuICBwcml2YXRlIHN5bWJvbGl6ZShjb21ibzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb21ib1NwbGl0OiBzdHJpbmdbXSA9IGNvbWJvLnNwbGl0KCcrJyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21ib1NwbGl0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyB0cnkgdG8gcmVzb2x2ZSBjb21tYW5kIC8gY3RybCBiYXNlZCBvbiBPUzpcbiAgICAgIGlmIChjb21ib1NwbGl0W2ldID09PSAnbW9kJykge1xuICAgICAgICBpZiAod2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtLmluZGV4T2YoJ01hYycpID49IDApIHtcbiAgICAgICAgICBjb21ib1NwbGl0W2ldID0gJ2NvbW1hbmQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbWJvU3BsaXRbaV0gPSAnY3RybCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbWJvU3BsaXRbaV0gPSB0aGlzLl9tYXBbY29tYm9TcGxpdFtpXV0gfHwgY29tYm9TcGxpdFtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbWJvU3BsaXQuam9pbignICsgJyk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fc3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgdG9nZ2xlQ2hlYXRTaGVldCgpOiB2b2lkIHtcbiAgICB0aGlzLmhlbHBWaXNpYmxlID0gIXRoaXMuaGVscFZpc2libGU7XG4gIH1cbn1cbiIsImltcG9ydCB7TW9kdWxlV2l0aFByb3ZpZGVycywgTmdNb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtDb21tb25Nb2R1bGV9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5cbmltcG9ydCB7Tmd4Q2hlYXRzaGVldENvbXBvbmVudH0gZnJvbSAnLi9uZ3gtY2hlYXRzaGVldC9uZ3gtY2hlYXRzaGVldC5jb21wb25lbnQnO1xuaW1wb3J0IHtOZ3hIb3RrZXlzRGlyZWN0aXZlfSBmcm9tICcuL25neC1ob3RrZXlzLmRpcmVjdGl2ZSc7XG5pbXBvcnQge05neEhvdGtleXNTZXJ2aWNlfSBmcm9tICcuL25neC1ob3RrZXlzLnNlcnZpY2UnO1xuaW1wb3J0IHtIb3RrZXlPcHRpb25zfSBmcm9tICcuL3Rva2VuJztcbmltcG9ydCB7SUhvdGtleU9wdGlvbnN9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5cbkBOZ01vZHVsZSh7XG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxuICBkZWNsYXJhdGlvbnM6IFtOZ3hDaGVhdHNoZWV0Q29tcG9uZW50LCBOZ3hIb3RrZXlzRGlyZWN0aXZlXSxcbiAgZXhwb3J0czogW05neEhvdGtleXNEaXJlY3RpdmUsIE5neENoZWF0c2hlZXRDb21wb25lbnRdLFxuICBwcm92aWRlcnM6IFtOZ3hIb3RrZXlzU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgTmd4SG90a2V5c01vZHVsZSB7XG4gIHN0YXRpYyBmb3JSb290KG9wdGlvbnM/OiBJSG90a2V5T3B0aW9ucyk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xuICAgIHJldHVybiB7XG4gICAgICBuZ01vZHVsZTogTmd4SG90a2V5c01vZHVsZSxcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICBOZ3hIb3RrZXlzU2VydmljZSxcbiAgICAgICAge3Byb3ZpZGU6IEhvdGtleU9wdGlvbnMsIHVzZVZhbHVlOiBvcHRpb25zfVxuICAgICAgXVxuICAgIH07XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJJbmplY3Rpb25Ub2tlbiIsIlN1YmplY3QiLCJzaGFyZSIsIkluamVjdGFibGUiLCJJbmplY3QiLCJ0c2xpYl8xLl9fdmFsdWVzIiwiRGlyZWN0aXZlIiwiRWxlbWVudFJlZiIsIklucHV0IiwiQ29tcG9uZW50IiwiTmdNb2R1bGUiLCJDb21tb25Nb2R1bGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUlBLFFBQWEsYUFBYSxHQUFHLElBQUlBLG1CQUFjLENBQWlCLGVBQWUsQ0FBQzs7Ozs7O0FDSmhGO0lBU0EsSUFBTSxlQUFlLEdBQW1CO1FBQ3RDLGlCQUFpQixFQUFFLEtBQUs7UUFDeEIsZUFBZSxFQUFFLHFCQUFxQjtRQUN0QyxnQkFBZ0IsRUFBRSxHQUFHO1FBQ3JCLDJCQUEyQixFQUFFLDRCQUE0QjtRQUN6RCxrQkFBa0IsRUFBRSxLQUFLO1FBQ3pCLDZCQUE2QixFQUFFLHFCQUFxQjtLQUNyRCxDQUFDOztRQVlBLDJCQUEyQyxRQUF3QjtZQUF4QixhQUFRLEdBQVIsUUFBUSxDQUFnQjtzQ0FOeEIsSUFBSSxHQUFHLEVBQUU7a0NBQ2IsSUFBSSxHQUFHLEVBQUU7c0NBRUwsSUFBSUMsWUFBTyxFQUFFOzhCQUNuQyxDQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsVUFBVSxDQUFDO1lBR2xELElBQUksQ0FBQyxlQUFlLEdBQUcsTUFBTSxDQUFD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